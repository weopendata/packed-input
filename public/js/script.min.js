/**
 * Enabling switches
 */
$('.form-enabler-switch').each(enablingSwitches);
$('.form-enabler-switch').on('change', enablingSwitches);
$('.switch').on('change', buildQueryObj);

function enablingSwitches() {
    var row = $(this).closest('.row');

    // Enable / disable row
    if ($('input', $(this)).is(':checked')) {
        $('input', row).prop('disabled', false);
    } else {
        $('input', row).prop('disabled', true);
    }

    // Re-enable switch
    $('input', this).prop('disabled', false);
}


/**
 * Form submission
 */
$('form').on('submit', search);

/**
 * Query object
 */
var queryObj = {};
function buildQueryObj() {
    queryObj = {};

    $('form input').not('input[id*=enabled], input[type=submit]').each(function(){
        var e = $(this);

        // Leave out disabled properties
        if(!e.prop('disabled')){
            queryObj[e.attr('id')] = e.val();
        }
    })

    // Push state
    history.replaceState({}, 'PID demonstrator', '?' + $.param(queryObj));
}

/**
 * Initial load
 */
jQuery.extend({
  getQueryParameters : function(str) {
      return (str || document.location.search).replace(/(^\?)/,'').split("&").map(function(n){return n = n.split("="),this[n[0]] = n[1],this}.bind({}))[0];
  }
});

function init() {
    var obj = $.getQueryParameters();
    var keys = Object.keys(obj);
    if(keys.length > 0 && keys[0] != ""){

        // Reset form
        $('.form-enabler-switch input').each(function(){
            $(this).prop('checked', false);
            var row = $(this).closest('.row');
            $('input:not(input[type=checkbox])', row).prop('disabled', true);
        });

        // Init fields based on query
        for(var key in obj){
            var value = obj[key];
            $('#' + key).val(decodeURIComponent(value).replace(/\+/g, ' '));

            var row = $('#' + key).closest('.row.parent');
            $('input[type=checkbox]', row).prop('checked', true);
            $('input', row).prop('disabled', false);
        }

        // Search on link click
        $('form').submit();
    }

    buildQueryObj();
}


$(document).ready(function(){
    init();
})


/* **********************************************
     Begin autocomplete.js
********************************************** */

var cache = {};

$('input[data-autocomplete]').each(function(){
    var el = $(this);
    el.autocomplete({
        minLength: 2,
        source: function( request, response ) {
            var localQueryObject = {};
            var property = el.data('property');
            localQueryObject.index = (queryObj.index == 'false')? 'false' : 'true';
            localQueryObject[property] = request.term;

            // Check autocomplete option
            if($('#autocomplete_enabled').is(':checked')){
                // Cache
                var term = property + request.term + localQueryObject.index;
                if (term in cache) {
                  response(cache[term]);
                  return;
                }

                // Fetch results
                $.getJSON( baseURL + "suggest?", localQueryObject, function( data, status, xhr ) {
                    cache[term] = data;
                    response(data);
                });
            }
        },

        // Force pick a value
        // select: function (event, ui) {
        //     return false;
        // },

        // select: function (event, ui) {
        //     $(this).val(ui.item ? ui.item : " ");
        // },

        // change: function (event, ui) {
        //     if (!ui.item) {
        //         this.value = '';
        //     }
        // }
    }).keyup(function (e) {
        if(e.which === 13) {
            $(".ui-autocomplete").hide();
        }
    });
})

/* **********************************************
     Begin search.js
********************************************** */

function search(e){
    e.preventDefault();

    // Angular controller
    var controller = angular.element($('#results')).scope();

    // Get form and submit button
    var form = $(e.target);
    var submit = $('button[type=submit]', form);

    // Disable submit button
    submit.prop('disabled', true);

    // Clear previous errors
    $('.row', form).removeClass('error');

    // Clear previous results
    $('#searchStatus', form).html('');
    controller.reset();

    // Rebuild query object
    buildQueryObj();

    // Build data object
    var localQueryObject = {};
    var validated = true;
    var minimumOne = false;
    $('form input[data-property]:not(:disabled)').each(function(){
        var value = $(this).val();
        localQueryObject[$(this).data('property')] = value;

        if(!value || value == ''){
            $(this).closest('.row').addClass('error');
            validated = false;
        }

        minimumOne = true;
    });

    if(!validated){
        resetForm();
    }else if(!minimumOne){
        $('#searchStatus', form).html('Kies minstens één van de bovenstaande filters.');
        resetForm();
    }else{
        $('#results').show();
        $('.fa-spin').removeClass('hidden').stop().fadeIn();
        controller.loadWorks(localQueryObject);
    }
}

/**
 * Reset form for next search
 */
function resetForm() {
    var submit = $('button[type=submit]');
    submit.prop('disabled', false);
}

/**
 * Search status text
 */
function updateSearchStatus(data) {
    var count = data.length;

    if(count == 0){
        status = 'Geen resultaten';
    }else if(count == 1){
        status = '1 resultaat';
    }else{
        status = count + ' resultaten';
    }

    $('#searchStatus').html(status + ' gevonden.');
}


/* **********************************************
     Begin alerts.js
********************************************** */

(function (global, undefined) {
    "use strict";

    var document = global.document,
        Alertify;

    Alertify = function () {

        var _alertify = {},
            dialogs   = {},
            isopen    = false,
            keys      = { ENTER: 13, ESC: 27, SPACE: 32 },
            queue     = [],
            $, btnCancel, btnOK, btnReset, btnResetBack, btnFocus, elCallee, elCover, elDialog, elLog, form, input, getTransitionEvent;

        /**
         * Markup pieces
         * @type {Object}
         */
        dialogs = {
            buttons : {
                holder : "<nav class=\"alertify-buttons\">{{buttons}}</nav>",
                submit : "<button type=\"submit\" class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
                ok     : "<button class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
                cancel : "<button class=\"alertify-button alertify-button-cancel\" id=\"alertify-cancel\">{{cancel}}</button>"
            },
            input   : "<div class=\"alertify-text-wrapper\"><input type=\"text\" class=\"alertify-text\" id=\"alertify-text\"></div>",
            message : "<p class=\"alertify-message\">{{message}}</p>",
            log     : "<article class=\"alertify-log{{class}}\">{{message}}</article>"
        };

        /**
         * Return the proper transitionend event
         * @return {String}    Transition type string
         */
        getTransitionEvent = function () {
            var t,
                type,
                supported   = false,
                el          = document.createElement("fakeelement"),
                transitions = {
                    "WebkitTransition" : "webkitTransitionEnd",
                    "MozTransition"    : "transitionend",
                    "OTransition"      : "otransitionend",
                    "transition"       : "transitionend"
                };

            for (t in transitions) {
                if (el.style[t] !== undefined) {
                    type      = transitions[t];
                    supported = true;
                    break;
                }
            }

            return {
                type      : type,
                supported : supported
            };
        };

        /**
         * Shorthand for document.getElementById()
         *
         * @param  {String} id    A specific element ID
         * @return {Object}       HTML element
         */
        $ = function (id) {
            return document.getElementById(id);
        };

        /**
         * Alertify private object
         * @type {Object}
         */
        _alertify = {

            /**
             * Labels object
             * @type {Object}
             */
            labels : {
                ok     : "OK",
                cancel : "Cancel"
            },

            /**
             * Delay number
             * @type {Number}
             */
            delay : 5000,

            /**
             * Whether buttons are reversed (default is secondary/primary)
             * @type {Boolean}
             */
            buttonReverse : false,

            /**
             * Which button should be focused by default
             * @type {String}   "ok" (default), "cancel", or "none"
             */
            buttonFocus : "ok",

            /**
             * Set the transition event on load
             * @type {[type]}
             */
            transition : undefined,

            /**
             * Set the proper button click events
             *
             * @param {Function} fn    [Optional] Callback function
             *
             * @return {undefined}
             */
            addListeners : function (fn) {
                var hasOK     = (typeof btnOK !== "undefined"),
                    hasCancel = (typeof btnCancel !== "undefined"),
                    hasInput  = (typeof input !== "undefined"),
                    val       = "",
                    self      = this,
                    ok, cancel, common, key, reset;

                // ok event handler
                ok = function (event) {
                    if (typeof event.preventDefault !== "undefined") event.preventDefault();
                    common(event);
                    if (typeof input !== "undefined") val = input.value;
                    if (typeof fn === "function") {
                        if (typeof input !== "undefined") {
                            fn(true, val);
                        }
                        else fn(true);
                    }
                    return false;
                };

                // cancel event handler
                cancel = function (event) {
                    if (typeof event.preventDefault !== "undefined") event.preventDefault();
                    common(event);
                    if (typeof fn === "function") fn(false);
                    return false;
                };

                // common event handler (keyup, ok and cancel)
                common = function (event) {
                    self.hide();
                    self.unbind(document.body, "keyup", key);
                    self.unbind(btnReset, "focus", reset);
                    if (hasOK) self.unbind(btnOK, "click", ok);
                    if (hasCancel) self.unbind(btnCancel, "click", cancel);
                };

                // keyup handler
                key = function (event) {
                    var keyCode = event.keyCode;
                    if ((keyCode === keys.SPACE && !hasInput) || (hasInput && keyCode === keys.ENTER)) ok(event);
                    if (keyCode === keys.ESC && hasCancel) cancel(event);
                };

                // reset focus to first item in the dialog
                reset = function (event) {
                    if (hasInput) input.focus();
                    else if (!hasCancel || self.buttonReverse) btnOK.focus();
                    else btnCancel.focus();
                };

                // handle reset focus link
                // this ensures that the keyboard focus does not
                // ever leave the dialog box until an action has
                // been taken
                this.bind(btnReset, "focus", reset);
                this.bind(btnResetBack, "focus", reset);
                // handle OK click
                if (hasOK) this.bind(btnOK, "click", ok);
                // handle Cancel click
                if (hasCancel) this.bind(btnCancel, "click", cancel);
                // listen for keys, Cancel => ESC
                this.bind(document.body, "keyup", key);
                if (!this.transition.supported) {
                    this.setFocus();
                }
            },

            /**
             * Bind events to elements
             *
             * @param  {Object}   el       HTML Object
             * @param  {Event}    event    Event to attach to element
             * @param  {Function} fn       Callback function
             *
             * @return {undefined}
             */
            bind : function (el, event, fn) {
                if (typeof el.addEventListener === "function") {
                    el.addEventListener(event, fn, false);
                } else if (el.attachEvent) {
                    el.attachEvent("on" + event, fn);
                }
            },

            /**
             * Use alertify as the global error handler (using window.onerror)
             *
             * @return {boolean} success
             */
            handleErrors : function () {
                if (typeof global.onerror !== "undefined") {
                    var self = this;
                    global.onerror = function (msg, url, line) {
                        self.error("[" + msg + " on line " + line + " of " + url + "]", 0);
                    };
                    return true;
                } else {
                    return false;
                }
            },

            /**
             * Append button HTML strings
             *
             * @param {String} secondary    The secondary button HTML string
             * @param {String} primary      The primary button HTML string
             *
             * @return {String}             The appended button HTML strings
             */
            appendButtons : function (secondary, primary) {
                return this.buttonReverse ? primary + secondary : secondary + primary;
            },

            /**
             * Build the proper message box
             *
             * @param  {Object} item    Current object in the queue
             *
             * @return {String}         An HTML string of the message box
             */
            build : function (item) {
                var html    = "",
                    type    = item.type,
                    message = item.message,
                    css     = item.cssClass || "";

                html += "<div class=\"alertify-dialog\">";
                html += "<a id=\"alertify-resetFocusBack\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";

                if (_alertify.buttonFocus === "none") html += "<a href=\"#\" id=\"alertify-noneFocus\" class=\"alertify-hidden\"></a>";

                // doens't require an actual form
                if (type === "prompt") html += "<div id=\"alertify-form\">";

                html += "<article class=\"alertify-inner\">";
                html += dialogs.message.replace("{{message}}", message);

                if (type === "prompt") html += dialogs.input;

                html += dialogs.buttons.holder;
                html += "</article>";

                if (type === "prompt") html += "</div>";

                html += "<a id=\"alertify-resetFocus\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";
                html += "</div>";

                switch (type) {
                case "confirm":
                    html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.ok));
                    html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
                    break;
                case "prompt":
                    html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.submit));
                    html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
                    break;
                case "alert":
                    html = html.replace("{{buttons}}", dialogs.buttons.ok);
                    html = html.replace("{{ok}}", this.labels.ok);
                    break;
                default:
                    break;
                }

                elDialog.className = "alertify alertify-" + type + " " + css;
                elCover.className  = "alertify-cover";
                return html;
            },

            /**
             * Close the log messages
             *
             * @param  {Object} elem    HTML Element of log message to close
             * @param  {Number} wait    [optional] Time (in ms) to wait before automatically hiding the message, if 0 never hide
             *
             * @return {undefined}
             */
            close : function (elem, wait) {
                // Unary Plus: +"2" === 2
                var timer = (wait && !isNaN(wait)) ? +wait : this.delay,
                    self  = this,
                    hideElement, transitionDone;

                // set click event on log messages
                this.bind(elem, "click", function () {
                    hideElement(elem);
                });
                // Hide the dialog box after transition
                // This ensure it doens't block any element from being clicked
                transitionDone = function (event) {
                    event.stopPropagation();
                    // unbind event so function only gets called once
                    self.unbind(this, self.transition.type, transitionDone);
                    // remove log message
                    elLog.removeChild(this);
                    if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
                };
                // this sets the hide class to transition out
                // or removes the child if css transitions aren't supported
                hideElement = function (el) {
                    // ensure element exists
                    if (typeof el !== "undefined" && el.parentNode === elLog) {
                        // whether CSS transition exists
                        if (self.transition.supported) {
                            self.bind(el, self.transition.type, transitionDone);
                            el.className += " alertify-log-hide";
                        } else {
                            elLog.removeChild(el);
                            if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
                        }
                    }
                };
                // never close (until click) if wait is set to 0
                if (wait === 0) return;
                // set timeout to auto close the log message
                setTimeout(function () { hideElement(elem); }, timer);
            },

            /**
             * Create a dialog box
             *
             * @param  {String}   message        The message passed from the callee
             * @param  {String}   type           Type of dialog to create
             * @param  {Function} fn             [Optional] Callback function
             * @param  {String}   placeholder    [Optional] Default value for prompt input field
             * @param  {String}   cssClass       [Optional] Class(es) to append to dialog box
             *
             * @return {Object}
             */
            dialog : function (message, type, fn, placeholder, cssClass) {
                // set the current active element
                // this allows the keyboard focus to be resetted
                // after the dialog box is closed
                elCallee = document.activeElement;
                // check to ensure the alertify dialog element
                // has been successfully created
                var check = function () {
                    if ((elLog && elLog.scrollTop !== null) && (elCover && elCover.scrollTop !== null)) return;
                    else check();
                };
                // error catching
                if (typeof message !== "string") throw new Error("message must be a string");
                if (typeof type !== "string") throw new Error("type must be a string");
                if (typeof fn !== "undefined" && typeof fn !== "function") throw new Error("fn must be a function");
                // initialize alertify if it hasn't already been done
                this.init();
                check();

                queue.push({ type: type, message: message, callback: fn, placeholder: placeholder, cssClass: cssClass });
                if (!isopen) this.setup();

                return this;
            },

            /**
             * Extend the log method to create custom methods
             *
             * @param  {String} type    Custom method name
             *
             * @return {Function}
             */
            extend : function (type) {
                if (typeof type !== "string") throw new Error("extend method must have exactly one paramter");
                return function (message, wait) {
                    this.log(message, type, wait);
                    return this;
                };
            },

            /**
             * Hide the dialog and rest to defaults
             *
             * @return {undefined}
             */
            hide : function () {
                var transitionDone,
                    self = this;
                // remove reference from queue
                queue.splice(0,1);
                // if items remaining in the queue
                if (queue.length > 0) this.setup(true);
                else {
                    isopen = false;
                    // Hide the dialog box after transition
                    // This ensure it doens't block any element from being clicked
                    transitionDone = function (event) {
                        event.stopPropagation();
                        // unbind event so function only gets called once
                        self.unbind(elDialog, self.transition.type, transitionDone);
                    };
                    // whether CSS transition exists
                    if (this.transition.supported) {
                        this.bind(elDialog, this.transition.type, transitionDone);
                        elDialog.className = "alertify alertify-hide alertify-hidden";
                    } else {
                        elDialog.className = "alertify alertify-hide alertify-hidden alertify-isHidden";
                    }
                    elCover.className  = "alertify-cover alertify-cover-hidden";
                    // set focus to the last element or body
                    // after the dialog is closed
                    elCallee.focus();
                }
            },

            /**
             * Initialize Alertify
             * Create the 2 main elements
             *
             * @return {undefined}
             */
            init : function () {
                // ensure legacy browsers support html5 tags
                document.createElement("nav");
                document.createElement("article");
                document.createElement("section");
                // cover
                if ($("alertify-cover") == null) {
                    elCover = document.createElement("div");
                    elCover.setAttribute("id", "alertify-cover");
                    elCover.className = "alertify-cover alertify-cover-hidden";
                    document.body.appendChild(elCover);
                }
                // main element
                if ($("alertify") == null) {
                    isopen = false;
                    queue = [];
                    elDialog = document.createElement("section");
                    elDialog.setAttribute("id", "alertify");
                    elDialog.className = "alertify alertify-hidden";
                    document.body.appendChild(elDialog);
                }
                // log element
                if ($("alertify-logs") == null) {
                    elLog = document.createElement("section");
                    elLog.setAttribute("id", "alertify-logs");
                    elLog.className = "alertify-logs alertify-logs-hidden";
                    document.body.appendChild(elLog);
                }
                // set tabindex attribute on body element
                // this allows script to give it focus
                // after the dialog is closed
                document.body.setAttribute("tabindex", "0");
                // set transition type
                this.transition = getTransitionEvent();
            },

            /**
             * Show a new log message box
             *
             * @param  {String} message    The message passed from the callee
             * @param  {String} type       [Optional] Optional type of log message
             * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding the log
             *
             * @return {Object}
             */
            log : function (message, type, wait) {
                // check to ensure the alertify dialog element
                // has been successfully created
                var check = function () {
                    if (elLog && elLog.scrollTop !== null) return;
                    else check();
                };
                // initialize alertify if it hasn't already been done
                this.init();
                check();

                elLog.className = "alertify-logs";
                this.notify(message, type, wait);
                return this;
            },

            /**
             * Add new log message
             * If a type is passed, a class name "alertify-log-{type}" will get added.
             * This allows for custom look and feel for various types of notifications.
             *
             * @param  {String} message    The message passed from the callee
             * @param  {String} type       [Optional] Type of log message
             * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding
             *
             * @return {undefined}
             */
            notify : function (message, type, wait) {
                var log = document.createElement("article");
                log.className = "alertify-log" + ((typeof type === "string" && type !== "") ? " alertify-log-" + type : "");
                log.innerHTML = message;
                // append child
                elLog.appendChild(log);
                // triggers the CSS animation
                setTimeout(function() { log.className = log.className + " alertify-log-show"; }, 50);
                this.close(log, wait);
            },

            /**
             * Set properties
             *
             * @param {Object} args     Passing parameters
             *
             * @return {undefined}
             */
            set : function (args) {
                var k;
                // error catching
                if (typeof args !== "object" && args instanceof Array) throw new Error("args must be an object");
                // set parameters
                for (k in args) {
                    if (args.hasOwnProperty(k)) {
                        this[k] = args[k];
                    }
                }
            },

            /**
             * Common place to set focus to proper element
             *
             * @return {undefined}
             */
            setFocus : function () {
                if (input) {
                    input.focus();
                    input.select();
                }
                else btnFocus.focus();
            },

            /**
             * Initiate all the required pieces for the dialog box
             *
             * @return {undefined}
             */
            setup : function (fromQueue) {
                var item = queue[0],
                    self = this,
                    transitionDone;

                // dialog is open
                isopen = true;
                // Set button focus after transition
                transitionDone = function (event) {
                    event.stopPropagation();
                    self.setFocus();
                    // unbind event so function only gets called once
                    self.unbind(elDialog, self.transition.type, transitionDone);
                };
                // whether CSS transition exists
                if (this.transition.supported && !fromQueue) {
                    this.bind(elDialog, this.transition.type, transitionDone);
                }
                // build the proper dialog HTML
                elDialog.innerHTML = this.build(item);
                // assign all the common elements
                btnReset  = $("alertify-resetFocus");
                btnResetBack  = $("alertify-resetFocusBack");
                btnOK     = $("alertify-ok")     || undefined;
                btnCancel = $("alertify-cancel") || undefined;
                btnFocus  = (_alertify.buttonFocus === "cancel") ? btnCancel : ((_alertify.buttonFocus === "none") ? $("alertify-noneFocus") : btnOK),
                input     = $("alertify-text")   || undefined;
                form      = $("alertify-form")   || undefined;
                // add placeholder value to the input field
                if (typeof item.placeholder === "string" && item.placeholder !== "") input.value = item.placeholder;
                if (fromQueue) this.setFocus();
                this.addListeners(item.callback);
            },

            /**
             * Unbind events to elements
             *
             * @param  {Object}   el       HTML Object
             * @param  {Event}    event    Event to detach to element
             * @param  {Function} fn       Callback function
             *
             * @return {undefined}
             */
            unbind : function (el, event, fn) {
                if (typeof el.removeEventListener === "function") {
                    el.removeEventListener(event, fn, false);
                } else if (el.detachEvent) {
                    el.detachEvent("on" + event, fn);
                }
            }
        };

        return {
            alert   : function (message, fn, cssClass) { _alertify.dialog(message, "alert", fn, "", cssClass); return this; },
            confirm : function (message, fn, cssClass) { _alertify.dialog(message, "confirm", fn, "", cssClass); return this; },
            extend  : _alertify.extend,
            init    : _alertify.init,
            log     : function (message, type, wait) { _alertify.log(message, type, wait); return this; },
            prompt  : function (message, fn, placeholder, cssClass) { _alertify.dialog(message, "prompt", fn, placeholder, cssClass); return this; },
            success : function (message, wait) { _alertify.log(message, "success", wait); return this; },
            error   : function (message, wait) { _alertify.log(message, "error", wait); return this; },
            set     : function (args) { _alertify.set(args); },
            labels  : _alertify.labels,
            debug   : _alertify.handleErrors
        };
    };

    // AMD and window support
    if (typeof define === "function") {
        define([], function () { return new Alertify(); });
    } else if (typeof global.alertify === "undefined") {
        global.alertify = new Alertify();
    }

}(this));


/* **********************************************
     Begin tether.js
********************************************** */

/* tether 0.6.5 */


(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require,exports,module);
  } else {
    root.Tether = factory();
  }
}(this, function(require,exports,module) {

(function() {
  var Evented, addClass, defer, deferred, extend, flush, getBounds, getOffsetParent, getOrigin, getScrollBarSize, getScrollParent, hasClass, node, removeClass, uniqueId, updateClasses, zeroPosCache,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  if (this.Tether == null) {
    this.Tether = {
      modules: []
    };
  }

  getScrollParent = function(el) {
    var parent, position, scrollParent, style, _ref;
    position = getComputedStyle(el).position;
    if (position === 'fixed') {
      return el;
    }
    scrollParent = void 0;
    parent = el;
    while (parent = parent.parentNode) {
      try {
        style = getComputedStyle(parent);
      } catch (_error) {}
      if (style == null) {
        return parent;
      }
      if (/(auto|scroll)/.test(style['overflow'] + style['overflow-y'] + style['overflow-x'])) {
        if (position !== 'absolute' || ((_ref = style['position']) === 'relative' || _ref === 'absolute' || _ref === 'fixed')) {
          return parent;
        }
      }
    }
    return document.body;
  };

  uniqueId = (function() {
    var id;
    id = 0;
    return function() {
      return id++;
    };
  })();

  zeroPosCache = {};

  getOrigin = function(doc) {
    var id, k, node, v, _ref;
    node = doc._tetherZeroElement;
    if (node == null) {
      node = doc.createElement('div');
      node.setAttribute('data-tether-id', uniqueId());
      extend(node.style, {
        top: 0,
        left: 0,
        position: 'absolute'
      });
      doc.body.appendChild(node);
      doc._tetherZeroElement = node;
    }
    id = node.getAttribute('data-tether-id');
    if (zeroPosCache[id] == null) {
      zeroPosCache[id] = {};
      _ref = node.getBoundingClientRect();
      for (k in _ref) {
        v = _ref[k];
        zeroPosCache[id][k] = v;
      }
      defer(function() {
        return zeroPosCache[id] = void 0;
      });
    }
    return zeroPosCache[id];
  };

  node = null;

  getBounds = function(el) {
    var box, doc, docEl, k, origin, v, _ref;
    if (el === document) {
      doc = document;
      el = document.documentElement;
    } else {
      doc = el.ownerDocument;
    }
    docEl = doc.documentElement;
    box = {};
    _ref = el.getBoundingClientRect();
    for (k in _ref) {
      v = _ref[k];
      box[k] = v;
    }
    origin = getOrigin(doc);
    box.top -= origin.top;
    box.left -= origin.left;
    if (box.width == null) {
      box.width = document.body.scrollWidth - box.left - box.right;
    }
    if (box.height == null) {
      box.height = document.body.scrollHeight - box.top - box.bottom;
    }
    box.top = box.top - docEl.clientTop;
    box.left = box.left - docEl.clientLeft;
    box.right = doc.body.clientWidth - box.width - box.left;
    box.bottom = doc.body.clientHeight - box.height - box.top;
    return box;
  };

  getOffsetParent = function(el) {
    return el.offsetParent || document.documentElement;
  };

  getScrollBarSize = function() {
    var inner, outer, width, widthContained, widthScroll;
    inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    outer = document.createElement('div');
    extend(outer.style, {
      position: 'absolute',
      top: 0,
      left: 0,
      pointerEvents: 'none',
      visibility: 'hidden',
      width: '200px',
      height: '150px',
      overflow: 'hidden'
    });
    outer.appendChild(inner);
    document.body.appendChild(outer);
    widthContained = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    width = widthContained - widthScroll;
    return {
      width: width,
      height: width
    };
  };

  extend = function(out) {
    var args, key, obj, val, _i, _len, _ref;
    if (out == null) {
      out = {};
    }
    args = [];
    Array.prototype.push.apply(args, arguments);
    _ref = args.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      obj = _ref[_i];
      if (obj) {
        for (key in obj) {
          if (!__hasProp.call(obj, key)) continue;
          val = obj[key];
          out[key] = val;
        }
      }
    }
    return out;
  };

  removeClass = function(el, name) {
    var cls, _i, _len, _ref, _results;
    if (el.classList != null) {
      _ref = name.split(' ');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cls = _ref[_i];
        if (cls.trim()) {
          _results.push(el.classList.remove(cls));
        }
      }
      return _results;
    } else {
      return el.className = el.className.replace(new RegExp("(^| )" + (name.split(' ').join('|')) + "( |$)", 'gi'), ' ');
    }
  };

  addClass = function(el, name) {
    var cls, _i, _len, _ref, _results;
    if (el.classList != null) {
      _ref = name.split(' ');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cls = _ref[_i];
        if (cls.trim()) {
          _results.push(el.classList.add(cls));
        }
      }
      return _results;
    } else {
      removeClass(el, name);
      return el.className += " " + name;
    }
  };

  hasClass = function(el, name) {
    if (el.classList != null) {
      return el.classList.contains(name);
    } else {
      return new RegExp("(^| )" + name + "( |$)", 'gi').test(el.className);
    }
  };

  updateClasses = function(el, add, all) {
    var cls, _i, _j, _len, _len1, _results;
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      cls = all[_i];
      if (__indexOf.call(add, cls) < 0) {
        if (hasClass(el, cls)) {
          removeClass(el, cls);
        }
      }
    }
    _results = [];
    for (_j = 0, _len1 = add.length; _j < _len1; _j++) {
      cls = add[_j];
      if (!hasClass(el, cls)) {
        _results.push(addClass(el, cls));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  deferred = [];

  defer = function(fn) {
    return deferred.push(fn);
  };

  flush = function() {
    var fn, _results;
    _results = [];
    while (fn = deferred.pop()) {
      _results.push(fn());
    }
    return _results;
  };

  Evented = (function() {
    function Evented() {}

    Evented.prototype.on = function(event, handler, ctx, once) {
      var _base;
      if (once == null) {
        once = false;
      }
      if (this.bindings == null) {
        this.bindings = {};
      }
      if ((_base = this.bindings)[event] == null) {
        _base[event] = [];
      }
      return this.bindings[event].push({
        handler: handler,
        ctx: ctx,
        once: once
      });
    };

    Evented.prototype.once = function(event, handler, ctx) {
      return this.on(event, handler, ctx, true);
    };

    Evented.prototype.off = function(event, handler) {
      var i, _ref, _results;
      if (((_ref = this.bindings) != null ? _ref[event] : void 0) == null) {
        return;
      }
      if (handler == null) {
        return delete this.bindings[event];
      } else {
        i = 0;
        _results = [];
        while (i < this.bindings[event].length) {
          if (this.bindings[event][i].handler === handler) {
            _results.push(this.bindings[event].splice(i, 1));
          } else {
            _results.push(i++);
          }
        }
        return _results;
      }
    };

    Evented.prototype.trigger = function() {
      var args, ctx, event, handler, i, once, _ref, _ref1, _results;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if ((_ref = this.bindings) != null ? _ref[event] : void 0) {
        i = 0;
        _results = [];
        while (i < this.bindings[event].length) {
          _ref1 = this.bindings[event][i], handler = _ref1.handler, ctx = _ref1.ctx, once = _ref1.once;
          handler.apply(ctx != null ? ctx : this, args);
          if (once) {
            _results.push(this.bindings[event].splice(i, 1));
          } else {
            _results.push(i++);
          }
        }
        return _results;
      }
    };

    return Evented;

  })();

  this.Tether.Utils = {
    getScrollParent: getScrollParent,
    getBounds: getBounds,
    getOffsetParent: getOffsetParent,
    extend: extend,
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    updateClasses: updateClasses,
    defer: defer,
    flush: flush,
    uniqueId: uniqueId,
    Evented: Evented,
    getScrollBarSize: getScrollBarSize
  };

}).call(this);

(function() {
  var MIRROR_LR, MIRROR_TB, OFFSET_MAP, Tether, addClass, addOffset, attachmentToOffset, autoToFixedAttachment, defer, extend, flush, getBounds, getOffsetParent, getOuterSize, getScrollBarSize, getScrollParent, getSize, now, offsetToPx, parseAttachment, parseOffset, position, removeClass, tethers, transformKey, updateClasses, within, _Tether, _ref,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.Tether == null) {
    throw new Error("You must include the utils.js file before tether.js");
  }

  Tether = this.Tether;

  _ref = Tether.Utils, getScrollParent = _ref.getScrollParent, getSize = _ref.getSize, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getOffsetParent = _ref.getOffsetParent, extend = _ref.extend, addClass = _ref.addClass, removeClass = _ref.removeClass, updateClasses = _ref.updateClasses, defer = _ref.defer, flush = _ref.flush, getScrollBarSize = _ref.getScrollBarSize;

  within = function(a, b, diff) {
    if (diff == null) {
      diff = 1;
    }
    return (a + diff >= b && b >= a - diff);
  };

  transformKey = (function() {
    var el, key, _i, _len, _ref1;
    el = document.createElement('div');
    _ref1 = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      key = _ref1[_i];
      if (el.style[key] !== void 0) {
        return key;
      }
    }
  })();

  tethers = [];

  position = function() {
    var tether, _i, _len;
    for (_i = 0, _len = tethers.length; _i < _len; _i++) {
      tether = tethers[_i];
      tether.position(false);
    }
    return flush();
  };

  now = function() {
    var _ref1;
    return (_ref1 = typeof performance !== "undefined" && performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) != null ? _ref1 : +(new Date);
  };

  (function() {
    var event, lastCall, lastDuration, pendingTimeout, tick, _i, _len, _ref1, _results;
    lastCall = null;
    lastDuration = null;
    pendingTimeout = null;
    tick = function() {
      if ((lastDuration != null) && lastDuration > 16) {
        lastDuration = Math.min(lastDuration - 16, 250);
        pendingTimeout = setTimeout(tick, 250);
        return;
      }
      if ((lastCall != null) && (now() - lastCall) < 10) {
        return;
      }
      if (pendingTimeout != null) {
        clearTimeout(pendingTimeout);
        pendingTimeout = null;
      }
      lastCall = now();
      position();
      return lastDuration = now() - lastCall;
    };
    _ref1 = ['resize', 'scroll', 'touchmove'];
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      event = _ref1[_i];
      _results.push(window.addEventListener(event, tick));
    }
    return _results;
  })();

  MIRROR_LR = {
    center: 'center',
    left: 'right',
    right: 'left'
  };

  MIRROR_TB = {
    middle: 'middle',
    top: 'bottom',
    bottom: 'top'
  };

  OFFSET_MAP = {
    top: 0,
    left: 0,
    middle: '50%',
    center: '50%',
    bottom: '100%',
    right: '100%'
  };

  autoToFixedAttachment = function(attachment, relativeToAttachment) {
    var left, top;
    left = attachment.left, top = attachment.top;
    if (left === 'auto') {
      left = MIRROR_LR[relativeToAttachment.left];
    }
    if (top === 'auto') {
      top = MIRROR_TB[relativeToAttachment.top];
    }
    return {
      left: left,
      top: top
    };
  };

  attachmentToOffset = function(attachment) {
    var _ref1, _ref2;
    return {
      left: (_ref1 = OFFSET_MAP[attachment.left]) != null ? _ref1 : attachment.left,
      top: (_ref2 = OFFSET_MAP[attachment.top]) != null ? _ref2 : attachment.top
    };
  };

  addOffset = function() {
    var left, offsets, out, top, _i, _len, _ref1;
    offsets = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    out = {
      top: 0,
      left: 0
    };
    for (_i = 0, _len = offsets.length; _i < _len; _i++) {
      _ref1 = offsets[_i], top = _ref1.top, left = _ref1.left;
      if (typeof top === 'string') {
        top = parseFloat(top, 10);
      }
      if (typeof left === 'string') {
        left = parseFloat(left, 10);
      }
      out.top += top;
      out.left += left;
    }
    return out;
  };

  offsetToPx = function(offset, size) {
    if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
      offset.left = parseFloat(offset.left, 10) / 100 * size.width;
    }
    if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
      offset.top = parseFloat(offset.top, 10) / 100 * size.height;
    }
    return offset;
  };

  parseAttachment = parseOffset = function(value) {
    var left, top, _ref1;
    _ref1 = value.split(' '), top = _ref1[0], left = _ref1[1];
    return {
      top: top,
      left: left
    };
  };

  _Tether = (function() {
    _Tether.modules = [];

    function _Tether(options) {
      this.position = __bind(this.position, this);
      var module, _i, _len, _ref1, _ref2;
      tethers.push(this);
      this.history = [];
      this.setOptions(options, false);
      _ref1 = Tether.modules;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        module = _ref1[_i];
        if ((_ref2 = module.initialize) != null) {
          _ref2.call(this);
        }
      }
      this.position();
    }

    _Tether.prototype.getClass = function(key) {
      var _ref1, _ref2;
      if ((_ref1 = this.options.classes) != null ? _ref1[key] : void 0) {
        return this.options.classes[key];
      } else if (((_ref2 = this.options.classes) != null ? _ref2[key] : void 0) !== false) {
        if (this.options.classPrefix) {
          return "" + this.options.classPrefix + "-" + key;
        } else {
          return key;
        }
      } else {
        return '';
      }
    };

    _Tether.prototype.setOptions = function(options, position) {
      var defaults, key, _i, _len, _ref1, _ref2;
      this.options = options;
      if (position == null) {
        position = true;
      }
      defaults = {
        offset: '0 0',
        targetOffset: '0 0',
        targetAttachment: 'auto auto',
        classPrefix: 'tether'
      };
      this.options = extend(defaults, this.options);
      _ref1 = this.options, this.element = _ref1.element, this.target = _ref1.target, this.targetModifier = _ref1.targetModifier;
      if (this.target === 'viewport') {
        this.target = document.body;
        this.targetModifier = 'visible';
      } else if (this.target === 'scroll-handle') {
        this.target = document.body;
        this.targetModifier = 'scroll-handle';
      }
      _ref2 = ['element', 'target'];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        key = _ref2[_i];
        if (this[key] == null) {
          throw new Error("Tether Error: Both element and target must be defined");
        }
        if (this[key].jquery != null) {
          this[key] = this[key][0];
        } else if (typeof this[key] === 'string') {
          this[key] = document.querySelector(this[key]);
        }
      }
      addClass(this.element, this.getClass('element'));
      addClass(this.target, this.getClass('target'));
      if (!this.options.attachment) {
        throw new Error("Tether Error: You must provide an attachment");
      }
      this.targetAttachment = parseAttachment(this.options.targetAttachment);
      this.attachment = parseAttachment(this.options.attachment);
      this.offset = parseOffset(this.options.offset);
      this.targetOffset = parseOffset(this.options.targetOffset);
      if (this.scrollParent != null) {
        this.disable();
      }
      if (this.targetModifier === 'scroll-handle') {
        this.scrollParent = this.target;
      } else {
        this.scrollParent = getScrollParent(this.target);
      }
      if (this.options.enabled !== false) {
        return this.enable(position);
      }
    };

    _Tether.prototype.getTargetBounds = function() {
      var bounds, fitAdj, hasBottomScroll, height, out, scrollBottom, scrollPercentage, style, target;
      if (this.targetModifier != null) {
        switch (this.targetModifier) {
          case 'visible':
            if (this.target === document.body) {
              return {
                top: pageYOffset,
                left: pageXOffset,
                height: innerHeight,
                width: innerWidth
              };
            } else {
              bounds = getBounds(this.target);
              out = {
                height: bounds.height,
                width: bounds.width,
                top: bounds.top,
                left: bounds.left
              };
              out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
              out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));
              out.height = Math.min(innerHeight, out.height);
              out.height -= 2;
              out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
              out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));
              out.width = Math.min(innerWidth, out.width);
              out.width -= 2;
              if (out.top < pageYOffset) {
                out.top = pageYOffset;
              }
              if (out.left < pageXOffset) {
                out.left = pageXOffset;
              }
              return out;
            }
            break;
          case 'scroll-handle':
            target = this.target;
            if (target === document.body) {
              target = document.documentElement;
              bounds = {
                left: pageXOffset,
                top: pageYOffset,
                height: innerHeight,
                width: innerWidth
              };
            } else {
              bounds = getBounds(target);
            }
            style = getComputedStyle(target);
            hasBottomScroll = target.scrollWidth > target.clientWidth || 'scroll' === [style.overflow, style.overflowX] || this.target !== document.body;
            scrollBottom = 0;
            if (hasBottomScroll) {
              scrollBottom = 15;
            }
            height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
            out = {
              width: 15,
              height: height * 0.975 * (height / target.scrollHeight),
              left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
            };
            fitAdj = 0;
            if (height < 408 && this.target === document.body) {
              fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
            }
            if (this.target !== document.body) {
              out.height = Math.max(out.height, 24);
            }
            scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
            out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
            if (this.target === document.body) {
              out.height = Math.max(out.height, 24);
            }
            return out;
        }
      } else {
        return getBounds(this.target);
      }
    };

    _Tether.prototype.clearCache = function() {
      return this._cache = {};
    };

    _Tether.prototype.cache = function(k, getter) {
      if (this._cache == null) {
        this._cache = {};
      }
      if (this._cache[k] == null) {
        this._cache[k] = getter.call(this);
      }
      return this._cache[k];
    };

    _Tether.prototype.enable = function(position) {
      if (position == null) {
        position = true;
      }
      addClass(this.target, this.getClass('enabled'));
      addClass(this.element, this.getClass('enabled'));
      this.enabled = true;
      if (this.scrollParent !== document) {
        this.scrollParent.addEventListener('scroll', this.position);
      }
      if (position) {
        return this.position();
      }
    };

    _Tether.prototype.disable = function() {
      removeClass(this.target, this.getClass('enabled'));
      removeClass(this.element, this.getClass('enabled'));
      this.enabled = false;
      if (this.scrollParent != null) {
        return this.scrollParent.removeEventListener('scroll', this.position);
      }
    };

    _Tether.prototype.destroy = function() {
      var i, tether, _i, _len, _results;
      this.disable();
      _results = [];
      for (i = _i = 0, _len = tethers.length; _i < _len; i = ++_i) {
        tether = tethers[i];
        if (tether === this) {
          tethers.splice(i, 1);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    _Tether.prototype.updateAttachClasses = function(elementAttach, targetAttach) {
      var add, all, side, sides, _i, _j, _len, _len1, _ref1,
        _this = this;
      if (elementAttach == null) {
        elementAttach = this.attachment;
      }
      if (targetAttach == null) {
        targetAttach = this.targetAttachment;
      }
      sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];
      if ((_ref1 = this._addAttachClasses) != null ? _ref1.length : void 0) {
        this._addAttachClasses.splice(0, this._addAttachClasses.length);
      }
      add = this._addAttachClasses != null ? this._addAttachClasses : this._addAttachClasses = [];
      if (elementAttach.top) {
        add.push("" + (this.getClass('element-attached')) + "-" + elementAttach.top);
      }
      if (elementAttach.left) {
        add.push("" + (this.getClass('element-attached')) + "-" + elementAttach.left);
      }
      if (targetAttach.top) {
        add.push("" + (this.getClass('target-attached')) + "-" + targetAttach.top);
      }
      if (targetAttach.left) {
        add.push("" + (this.getClass('target-attached')) + "-" + targetAttach.left);
      }
      all = [];
      for (_i = 0, _len = sides.length; _i < _len; _i++) {
        side = sides[_i];
        all.push("" + (this.getClass('element-attached')) + "-" + side);
      }
      for (_j = 0, _len1 = sides.length; _j < _len1; _j++) {
        side = sides[_j];
        all.push("" + (this.getClass('target-attached')) + "-" + side);
      }
      return defer(function() {
        if (_this._addAttachClasses == null) {
          return;
        }
        updateClasses(_this.element, _this._addAttachClasses, all);
        updateClasses(_this.target, _this._addAttachClasses, all);
        return _this._addAttachClasses = void 0;
      });
    };

    _Tether.prototype.position = function(flushChanges) {
      var elementPos, elementStyle, height, left, manualOffset, manualTargetOffset, module, next, offset, offsetBorder, offsetParent, offsetParentSize, offsetParentStyle, offsetPosition, ret, scrollLeft, scrollTop, scrollbarSize, side, targetAttachment, targetOffset, targetPos, targetSize, top, width, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
        _this = this;
      if (flushChanges == null) {
        flushChanges = true;
      }
      if (!this.enabled) {
        return;
      }
      this.clearCache();
      targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
      this.updateAttachClasses(this.attachment, targetAttachment);
      elementPos = this.cache('element-bounds', function() {
        return getBounds(_this.element);
      });
      width = elementPos.width, height = elementPos.height;
      if (width === 0 && height === 0 && (this.lastSize != null)) {
        _ref1 = this.lastSize, width = _ref1.width, height = _ref1.height;
      } else {
        this.lastSize = {
          width: width,
          height: height
        };
      }
      targetSize = targetPos = this.cache('target-bounds', function() {
        return _this.getTargetBounds();
      });
      offset = offsetToPx(attachmentToOffset(this.attachment), {
        width: width,
        height: height
      });
      targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
      manualOffset = offsetToPx(this.offset, {
        width: width,
        height: height
      });
      manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
      offset = addOffset(offset, manualOffset);
      targetOffset = addOffset(targetOffset, manualTargetOffset);
      left = targetPos.left + targetOffset.left - offset.left;
      top = targetPos.top + targetOffset.top - offset.top;
      _ref2 = Tether.modules;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        module = _ref2[_i];
        ret = module.position.call(this, {
          left: left,
          top: top,
          targetAttachment: targetAttachment,
          targetPos: targetPos,
          attachment: this.attachment,
          elementPos: elementPos,
          offset: offset,
          targetOffset: targetOffset,
          manualOffset: manualOffset,
          manualTargetOffset: manualTargetOffset,
          scrollbarSize: scrollbarSize
        });
        if ((ret == null) || typeof ret !== 'object') {
          continue;
        } else if (ret === false) {
          return false;
        } else {
          top = ret.top, left = ret.left;
        }
      }
      next = {
        page: {
          top: top,
          left: left
        },
        viewport: {
          top: top - pageYOffset,
          bottom: pageYOffset - top - height + innerHeight,
          left: left - pageXOffset,
          right: pageXOffset - left - width + innerWidth
        }
      };
      if (document.body.scrollWidth > window.innerWidth) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.bottom -= scrollbarSize.height;
      }
      if (document.body.scrollHeight > window.innerHeight) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.right -= scrollbarSize.width;
      }
      if (((_ref3 = document.body.style.position) !== '' && _ref3 !== 'static') || ((_ref4 = document.body.parentElement.style.position) !== '' && _ref4 !== 'static')) {
        next.page.bottom = document.body.scrollHeight - top - height;
        next.page.right = document.body.scrollWidth - left - width;
      }
      if (((_ref5 = this.options.optimizations) != null ? _ref5.moveElement : void 0) !== false && (this.targetModifier == null)) {
        offsetParent = this.cache('target-offsetparent', function() {
          return getOffsetParent(_this.target);
        });
        offsetPosition = this.cache('target-offsetparent-bounds', function() {
          return getBounds(offsetParent);
        });
        offsetParentStyle = getComputedStyle(offsetParent);
        elementStyle = getComputedStyle(this.element);
        offsetParentSize = offsetPosition;
        offsetBorder = {};
        _ref6 = ['Top', 'Left', 'Bottom', 'Right'];
        for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
          side = _ref6[_j];
          offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle["border" + side + "Width"]);
        }
        offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
        offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
        if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {
          if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {
            scrollTop = offsetParent.scrollTop;
            scrollLeft = offsetParent.scrollLeft;
            next.offset = {
              top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
              left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
            };
          }
        }
      }
      this.move(next);
      this.history.unshift(next);
      if (this.history.length > 3) {
        this.history.pop();
      }
      if (flushChanges) {
        flush();
      }
      return true;
    };

    _Tether.prototype.move = function(position) {
      var css, elVal, found, key, moved, offsetParent, point, same, transcribe, type, val, write, writeCSS, _i, _len, _ref1, _ref2,
        _this = this;
      if (this.element.parentNode == null) {
        return;
      }
      same = {};
      for (type in position) {
        same[type] = {};
        for (key in position[type]) {
          found = false;
          _ref1 = this.history;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            point = _ref1[_i];
            if (!within((_ref2 = point[type]) != null ? _ref2[key] : void 0, position[type][key])) {
              found = true;
              break;
            }
          }
          if (!found) {
            same[type][key] = true;
          }
        }
      }
      css = {
        top: '',
        left: '',
        right: '',
        bottom: ''
      };
      transcribe = function(same, pos) {
        var xPos, yPos, _ref3;
        if (((_ref3 = _this.options.optimizations) != null ? _ref3.gpu : void 0) !== false) {
          if (same.top) {
            css.top = 0;
            yPos = pos.top;
          } else {
            css.bottom = 0;
            yPos = -pos.bottom;
          }
          if (same.left) {
            css.left = 0;
            xPos = pos.left;
          } else {
            css.right = 0;
            xPos = -pos.right;
          }
          css[transformKey] = "translateX(" + (Math.round(xPos)) + "px) translateY(" + (Math.round(yPos)) + "px)";
          if (transformKey !== 'msTransform') {
            return css[transformKey] += " translateZ(0)";
          }
        } else {
          if (same.top) {
            css.top = "" + pos.top + "px";
          } else {
            css.bottom = "" + pos.bottom + "px";
          }
          if (same.left) {
            return css.left = "" + pos.left + "px";
          } else {
            return css.right = "" + pos.right + "px";
          }
        }
      };
      moved = false;
      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
        css.position = 'absolute';
        transcribe(same.page, position.page);
      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
        css.position = 'fixed';
        transcribe(same.viewport, position.viewport);
      } else if ((same.offset != null) && same.offset.top && same.offset.left) {
        css.position = 'absolute';
        offsetParent = this.cache('target-offsetparent', function() {
          return getOffsetParent(_this.target);
        });
        if (getOffsetParent(this.element) !== offsetParent) {
          defer(function() {
            _this.element.parentNode.removeChild(_this.element);
            return offsetParent.appendChild(_this.element);
          });
        }
        transcribe(same.offset, position.offset);
        moved = true;
      } else {
        css.position = 'absolute';
        transcribe({
          top: true,
          left: true
        }, position.page);
      }
      if (!moved && this.element.parentNode.tagName !== 'BODY') {
        this.element.parentNode.removeChild(this.element);
        document.body.appendChild(this.element);
      }
      writeCSS = {};
      write = false;
      for (key in css) {
        val = css[key];
        elVal = this.element.style[key];
        if (elVal !== '' && val !== '' && (key === 'top' || key === 'left' || key === 'bottom' || key === 'right')) {
          elVal = parseFloat(elVal);
          val = parseFloat(val);
        }
        if (elVal !== val) {
          write = true;
          writeCSS[key] = css[key];
        }
      }
      if (write) {
        return defer(function() {
          return extend(_this.element.style, writeCSS);
        });
      }
    };

    return _Tether;

  })();

  Tether.position = position;

  this.Tether = extend(_Tether, Tether);

}).call(this);

(function() {
  var BOUNDS_FORMAT, MIRROR_ATTACH, defer, extend, getBoundingRect, getBounds, getOuterSize, getSize, updateClasses, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = this.Tether.Utils, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getSize = _ref.getSize, extend = _ref.extend, updateClasses = _ref.updateClasses, defer = _ref.defer;

  MIRROR_ATTACH = {
    left: 'right',
    right: 'left',
    top: 'bottom',
    bottom: 'top',
    middle: 'middle'
  };

  BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];

  getBoundingRect = function(tether, to) {
    var i, pos, side, size, style, _i, _len;
    if (to === 'scrollParent') {
      to = tether.scrollParent;
    } else if (to === 'window') {
      to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
    }
    if (to === document) {
      to = to.documentElement;
    }
    if (to.nodeType != null) {
      pos = size = getBounds(to);
      style = getComputedStyle(to);
      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
      for (i = _i = 0, _len = BOUNDS_FORMAT.length; _i < _len; i = ++_i) {
        side = BOUNDS_FORMAT[i];
        side = side[0].toUpperCase() + side.substr(1);
        if (side === 'Top' || side === 'Left') {
          to[i] += parseFloat(style["border" + side + "Width"]);
        } else {
          to[i] -= parseFloat(style["border" + side + "Width"]);
        }
      }
    }
    return to;
  };

  this.Tether.modules.push({
    position: function(_arg) {
      var addClasses, allClasses, attachment, bounds, changeAttachX, changeAttachY, cls, constraint, eAttachment, height, left, oob, oobClass, p, pin, pinned, pinnedClass, removeClass, side, tAttachment, targetAttachment, targetHeight, targetSize, targetWidth, to, top, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      top = _arg.top, left = _arg.left, targetAttachment = _arg.targetAttachment;
      if (!this.options.constraints) {
        return true;
      }
      removeClass = function(prefix) {
        var side, _i, _len, _results;
        _this.removeClass(prefix);
        _results = [];
        for (_i = 0, _len = BOUNDS_FORMAT.length; _i < _len; _i++) {
          side = BOUNDS_FORMAT[_i];
          _results.push(_this.removeClass("" + prefix + "-" + side));
        }
        return _results;
      };
      _ref1 = this.cache('element-bounds', function() {
        return getBounds(_this.element);
      }), height = _ref1.height, width = _ref1.width;
      if (width === 0 && height === 0 && (this.lastSize != null)) {
        _ref2 = this.lastSize, width = _ref2.width, height = _ref2.height;
      }
      targetSize = this.cache('target-bounds', function() {
        return _this.getTargetBounds();
      });
      targetHeight = targetSize.height;
      targetWidth = targetSize.width;
      tAttachment = {};
      eAttachment = {};
      allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];
      _ref3 = this.options.constraints;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        constraint = _ref3[_i];
        if (constraint.outOfBoundsClass) {
          allClasses.push(constraint.outOfBoundsClass);
        }
        if (constraint.pinnedClass) {
          allClasses.push(constraint.pinnedClass);
        }
      }
      for (_j = 0, _len1 = allClasses.length; _j < _len1; _j++) {
        cls = allClasses[_j];
        _ref4 = ['left', 'top', 'right', 'bottom'];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          side = _ref4[_k];
          allClasses.push("" + cls + "-" + side);
        }
      }
      addClasses = [];
      tAttachment = extend({}, targetAttachment);
      eAttachment = extend({}, this.attachment);
      _ref5 = this.options.constraints;
      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
        constraint = _ref5[_l];
        to = constraint.to, attachment = constraint.attachment, pin = constraint.pin;
        if (attachment == null) {
          attachment = '';
        }
        if (__indexOf.call(attachment, ' ') >= 0) {
          _ref6 = attachment.split(' '), changeAttachY = _ref6[0], changeAttachX = _ref6[1];
        } else {
          changeAttachX = changeAttachY = attachment;
        }
        bounds = getBoundingRect(this, to);
        if (changeAttachY === 'target' || changeAttachY === 'both') {
          if (top < bounds[1] && tAttachment.top === 'top') {
            top += targetHeight;
            tAttachment.top = 'bottom';
          }
          if (top + height > bounds[3] && tAttachment.top === 'bottom') {
            top -= targetHeight;
            tAttachment.top = 'top';
          }
        }
        if (changeAttachY === 'together') {
          if (top < bounds[1] && tAttachment.top === 'top') {
            if (eAttachment.top === 'bottom') {
              top += targetHeight;
              tAttachment.top = 'bottom';
              top += height;
              eAttachment.top = 'top';
            } else if (eAttachment.top === 'top') {
              top += targetHeight;
              tAttachment.top = 'bottom';
              top -= height;
              eAttachment.top = 'bottom';
            }
          }
          if (top + height > bounds[3] && tAttachment.top === 'bottom') {
            if (eAttachment.top === 'top') {
              top -= targetHeight;
              tAttachment.top = 'top';
              top -= height;
              eAttachment.top = 'bottom';
            } else if (eAttachment.top === 'bottom') {
              top -= targetHeight;
              tAttachment.top = 'top';
              top += height;
              eAttachment.top = 'top';
            }
          }
          if (tAttachment.top === 'middle') {
            if (top + height > bounds[3] && eAttachment.top === 'top') {
              top -= height;
              eAttachment.top = 'bottom';
            } else if (top < bounds[1] && eAttachment.top === 'bottom') {
              top += height;
              eAttachment.top = 'top';
            }
          }
        }
        if (changeAttachX === 'target' || changeAttachX === 'both') {
          if (left < bounds[0] && tAttachment.left === 'left') {
            left += targetWidth;
            tAttachment.left = 'right';
          }
          if (left + width > bounds[2] && tAttachment.left === 'right') {
            left -= targetWidth;
            tAttachment.left = 'left';
          }
        }
        if (changeAttachX === 'together') {
          if (left < bounds[0] && tAttachment.left === 'left') {
            if (eAttachment.left === 'right') {
              left += targetWidth;
              tAttachment.left = 'right';
              left += width;
              eAttachment.left = 'left';
            } else if (eAttachment.left === 'left') {
              left += targetWidth;
              tAttachment.left = 'right';
              left -= width;
              eAttachment.left = 'right';
            }
          } else if (left + width > bounds[2] && tAttachment.left === 'right') {
            if (eAttachment.left === 'left') {
              left -= targetWidth;
              tAttachment.left = 'left';
              left -= width;
              eAttachment.left = 'right';
            } else if (eAttachment.left === 'right') {
              left -= targetWidth;
              tAttachment.left = 'left';
              left += width;
              eAttachment.left = 'left';
            }
          } else if (tAttachment.left === 'center') {
            if (left + width > bounds[2] && eAttachment.left === 'left') {
              left -= width;
              eAttachment.left = 'right';
            } else if (left < bounds[0] && eAttachment.left === 'right') {
              left += width;
              eAttachment.left = 'left';
            }
          }
        }
        if (changeAttachY === 'element' || changeAttachY === 'both') {
          if (top < bounds[1] && eAttachment.top === 'bottom') {
            top += height;
            eAttachment.top = 'top';
          }
          if (top + height > bounds[3] && eAttachment.top === 'top') {
            top -= height;
            eAttachment.top = 'bottom';
          }
        }
        if (changeAttachX === 'element' || changeAttachX === 'both') {
          if (left < bounds[0] && eAttachment.left === 'right') {
            left += width;
            eAttachment.left = 'left';
          }
          if (left + width > bounds[2] && eAttachment.left === 'left') {
            left -= width;
            eAttachment.left = 'right';
          }
        }
        if (typeof pin === 'string') {
          pin = (function() {
            var _len4, _m, _ref7, _results;
            _ref7 = pin.split(',');
            _results = [];
            for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
              p = _ref7[_m];
              _results.push(p.trim());
            }
            return _results;
          })();
        } else if (pin === true) {
          pin = ['top', 'left', 'right', 'bottom'];
        }
        pin || (pin = []);
        pinned = [];
        oob = [];
        if (top < bounds[1]) {
          if (__indexOf.call(pin, 'top') >= 0) {
            top = bounds[1];
            pinned.push('top');
          } else {
            oob.push('top');
          }
        }
        if (top + height > bounds[3]) {
          if (__indexOf.call(pin, 'bottom') >= 0) {
            top = bounds[3] - height;
            pinned.push('bottom');
          } else {
            oob.push('bottom');
          }
        }
        if (left < bounds[0]) {
          if (__indexOf.call(pin, 'left') >= 0) {
            left = bounds[0];
            pinned.push('left');
          } else {
            oob.push('left');
          }
        }
        if (left + width > bounds[2]) {
          if (__indexOf.call(pin, 'right') >= 0) {
            left = bounds[2] - width;
            pinned.push('right');
          } else {
            oob.push('right');
          }
        }
        if (pinned.length) {
          pinnedClass = (_ref7 = this.options.pinnedClass) != null ? _ref7 : this.getClass('pinned');
          addClasses.push(pinnedClass);
          for (_m = 0, _len4 = pinned.length; _m < _len4; _m++) {
            side = pinned[_m];
            addClasses.push("" + pinnedClass + "-" + side);
          }
        }
        if (oob.length) {
          oobClass = (_ref8 = this.options.outOfBoundsClass) != null ? _ref8 : this.getClass('out-of-bounds');
          addClasses.push(oobClass);
          for (_n = 0, _len5 = oob.length; _n < _len5; _n++) {
            side = oob[_n];
            addClasses.push("" + oobClass + "-" + side);
          }
        }
        if (__indexOf.call(pinned, 'left') >= 0 || __indexOf.call(pinned, 'right') >= 0) {
          eAttachment.left = tAttachment.left = false;
        }
        if (__indexOf.call(pinned, 'top') >= 0 || __indexOf.call(pinned, 'bottom') >= 0) {
          eAttachment.top = tAttachment.top = false;
        }
        if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {
          this.updateAttachClasses(eAttachment, tAttachment);
        }
      }
      defer(function() {
        updateClasses(_this.target, addClasses, allClasses);
        return updateClasses(_this.element, addClasses, allClasses);
      });
      return {
        top: top,
        left: left
      };
    }
  });

}).call(this);

(function() {
  var defer, getBounds, updateClasses, _ref;

  _ref = this.Tether.Utils, getBounds = _ref.getBounds, updateClasses = _ref.updateClasses, defer = _ref.defer;

  this.Tether.modules.push({
    position: function(_arg) {
      var abutted, addClasses, allClasses, bottom, height, left, right, side, sides, targetPos, top, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      top = _arg.top, left = _arg.left;
      _ref1 = this.cache('element-bounds', function() {
        return getBounds(_this.element);
      }), height = _ref1.height, width = _ref1.width;
      targetPos = this.getTargetBounds();
      bottom = top + height;
      right = left + width;
      abutted = [];
      if (top <= targetPos.bottom && bottom >= targetPos.top) {
        _ref2 = ['left', 'right'];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          side = _ref2[_i];
          if ((_ref3 = targetPos[side]) === left || _ref3 === right) {
            abutted.push(side);
          }
        }
      }
      if (left <= targetPos.right && right >= targetPos.left) {
        _ref4 = ['top', 'bottom'];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          side = _ref4[_j];
          if ((_ref5 = targetPos[side]) === top || _ref5 === bottom) {
            abutted.push(side);
          }
        }
      }
      allClasses = [];
      addClasses = [];
      sides = ['left', 'top', 'right', 'bottom'];
      allClasses.push(this.getClass('abutted'));
      for (_k = 0, _len2 = sides.length; _k < _len2; _k++) {
        side = sides[_k];
        allClasses.push("" + (this.getClass('abutted')) + "-" + side);
      }
      if (abutted.length) {
        addClasses.push(this.getClass('abutted'));
      }
      for (_l = 0, _len3 = abutted.length; _l < _len3; _l++) {
        side = abutted[_l];
        addClasses.push("" + (this.getClass('abutted')) + "-" + side);
      }
      defer(function() {
        updateClasses(_this.target, addClasses, allClasses);
        return updateClasses(_this.element, addClasses, allClasses);
      });
      return true;
    }
  });

}).call(this);

(function() {
  this.Tether.modules.push({
    position: function(_arg) {
      var left, result, shift, shiftLeft, shiftTop, top, _ref;
      top = _arg.top, left = _arg.left;
      if (!this.options.shift) {
        return;
      }
      result = function(val) {
        if (typeof val === 'function') {
          return val.call(this, {
            top: top,
            left: left
          });
        } else {
          return val;
        }
      };
      shift = result(this.options.shift);
      if (typeof shift === 'string') {
        shift = shift.split(' ');
        shift[1] || (shift[1] = shift[0]);
        shiftTop = shift[0], shiftLeft = shift[1];
        shiftTop = parseFloat(shiftTop, 10);
        shiftLeft = parseFloat(shiftLeft, 10);
      } else {
        _ref = [shift.top, shift.left], shiftTop = _ref[0], shiftLeft = _ref[1];
      }
      top += shiftTop;
      left += shiftLeft;
      return {
        top: top,
        left: left
      };
    }
  });

}).call(this);

return this.Tether;

}));


/* **********************************************
     Begin tooltip.js
********************************************** */

/*
 * qTip2 - Pretty powerful tooltips - v2.2.0
 * http://qtip2.com
 *
 * Copyright (c) 2014 Craig Michael Thompson
 * Released under the MIT, GPL licenses
 * http://jquery.org/license
 *
 * Date: Mon Mar 17 2014 08:51 EDT-0400
 * Plugins: None
 * Styles: basic
 */
/*global window: false, jQuery: false, console: false, define: false */

/* Cache window, document, undefined */
(function( window, document, undefined ) {

// Uses AMD or browser globals to create a jQuery plugin.
(function( factory ) {
    "use strict";
    if(typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    }
    else if(jQuery && !jQuery.fn.qtip) {
        factory(jQuery);
    }
}
(function($) {
    "use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

;// Munge the primitives - Paul Irish tip
var TRUE = true,
FALSE = false,
NULL = null,

// Common variables
X = 'x', Y = 'y',
WIDTH = 'width',
HEIGHT = 'height',

// Positioning sides
TOP = 'top',
LEFT = 'left',
BOTTOM = 'bottom',
RIGHT = 'right',
CENTER = 'center',

// Position adjustment types
FLIP = 'flip',
FLIPINVERT = 'flipinvert',
SHIFT = 'shift',

// Shortcut vars
QTIP, PROTOTYPE, CORNER, CHECKS,
PLUGINS = {},
NAMESPACE = 'qtip',
ATTR_HAS = 'data-hasqtip',
ATTR_ID = 'data-qtip-id',
WIDGET = ['ui-widget', 'ui-tooltip'],
SELECTOR = '.'+NAMESPACE,
INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

CLASS_FIXED = NAMESPACE+'-fixed',
CLASS_DEFAULT = NAMESPACE + '-default',
CLASS_FOCUS = NAMESPACE + '-focus',
CLASS_HOVER = NAMESPACE + '-hover',
CLASS_DISABLED = NAMESPACE+'-disabled',

replaceSuffix = '_replacedByqTip',
oldtitle = 'oldtitle',
trackingBound,

// Browser detection
BROWSER = {
    /*
     * IE version detection
     *
     * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
     * Credit to James Padolsey for the original implemntation!
     */
    ie: (function(){
        var v = 3, div = document.createElement('div');
        while ((div.innerHTML = '<!--[if gt IE '+(++v)+']><i></i><![endif]-->')) {
            if(!div.getElementsByTagName('i')[0]) { break; }
        }
        return v > 4 ? v : NaN;
    }()),

    /*
     * iOS version detection
     */
    iOS: parseFloat(
        ('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
        .replace('undefined', '3_2').replace('_', '.').replace('_', '')
    ) || FALSE
};

;function QTip(target, options, id, attr) {
    // Elements and ID
    this.id = id;
    this.target = target;
    this.tooltip = NULL;
    this.elements = { target: target };

    // Internal constructs
    this._id = NAMESPACE + '-' + id;
    this.timers = { img: {} };
    this.options = options;
    this.plugins = {};

    // Cache object
    this.cache = {
        event: {},
        target: $(),
        disabled: FALSE,
        attr: attr,
        onTooltip: FALSE,
        lastClass: ''
    };

    // Set the initial flags
    this.rendered = this.destroyed = this.disabled = this.waiting =
        this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
}
PROTOTYPE = QTip.prototype;

PROTOTYPE._when = function(deferreds) {
    return $.when.apply($, deferreds);
};

PROTOTYPE.render = function(show) {
    if(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

    var self = this,
        options = this.options,
        cache = this.cache,
        elements = this.elements,
        text = options.content.text,
        title = options.content.title,
        button = options.content.button,
        posOptions = options.position,
        namespace = '.'+this._id+' ',
        deferreds = [],
        tooltip;

    // Add ARIA attributes to target
    $.attr(this.target[0], 'aria-describedby', this._id);

    // Create tooltip element
    this.tooltip = elements.tooltip = tooltip = $('<div/>', {
        'id': this._id,
        'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, NAMESPACE + '-pos-' + options.position.my.abbrev() ].join(' '),
        'width': options.style.width || '',
        'height': options.style.height || '',
        'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

        /* ARIA specific attributes */
        'role': 'alert',
        'aria-live': 'polite',
        'aria-atomic': FALSE,
        'aria-describedby': this._id + '-content',
        'aria-hidden': TRUE
    })
    .toggleClass(CLASS_DISABLED, this.disabled)
    .attr(ATTR_ID, this.id)
    .data(NAMESPACE, this)
    .appendTo(posOptions.container)
    .append(
        // Create content element
        elements.content = $('<div />', {
            'class': NAMESPACE + '-content',
            'id': this._id + '-content',
            'aria-atomic': TRUE
        })
    );

    // Set rendered flag and prevent redundant reposition calls for now
    this.rendered = -1;
    this.positioning = TRUE;

    // Create title...
    if(title) {
        this._createTitle();

        // Update title only if its not a callback (called in toggle if so)
        if(!$.isFunction(title)) {
            deferreds.push( this._updateTitle(title, FALSE) );
        }
    }

    // Create button
    if(button) { this._createButton(); }

    // Set proper rendered flag and update content if not a callback function (called in toggle)
    if(!$.isFunction(text)) {
        deferreds.push( this._updateContent(text, FALSE) );
    }
    this.rendered = TRUE;

    // Setup widget classes
    this._setWidget();

    // Initialize 'render' plugins
    $.each(PLUGINS, function(name) {
        var instance;
        if(this.initialize === 'render' && (instance = this(self))) {
            self.plugins[name] = instance;
        }
    });

    // Unassign initial events and assign proper events
    this._unassignEvents();
    this._assignEvents();

    // When deferreds have completed
    this._when(deferreds).then(function() {
        // tooltiprender event
        self._trigger('render');

        // Reset flags
        self.positioning = FALSE;

        // Show tooltip if not hidden during wait period
        if(!self.hiddenDuringWait && (options.show.ready || show)) {
            self.toggle(TRUE, cache.event, FALSE);
        }
        self.hiddenDuringWait = FALSE;
    });

    // Expose API
    QTIP.api[this.id] = this;

    return this;
};

PROTOTYPE.destroy = function(immediate) {
    // Set flag the signify destroy is taking place to plugins
    // and ensure it only gets destroyed once!
    if(this.destroyed) { return this.target; }

    function process() {
        if(this.destroyed) { return; }
        this.destroyed = TRUE;

        var target = this.target,
            title = target.attr(oldtitle);

        // Destroy tooltip if rendered
        if(this.rendered) {
            this.tooltip.stop(1,0).find('*').remove().end().remove();
        }

        // Destroy all plugins
        $.each(this.plugins, function(name) {
            this.destroy && this.destroy();
        });

        // Clear timers and remove bound events
        clearTimeout(this.timers.show);
        clearTimeout(this.timers.hide);
        this._unassignEvents();

        // Remove api object and ARIA attributes
        target.removeData(NAMESPACE)
            .removeAttr(ATTR_ID)
            .removeAttr(ATTR_HAS)
            .removeAttr('aria-describedby');

        // Reset old title attribute if removed
        if(this.options.suppress && title) {
            target.attr('title', title).removeAttr(oldtitle);
        }

        // Remove qTip events associated with this API
        this._unbind(target);

        // Remove ID from used id objects, and delete object references
        // for better garbage collection and leak protection
        this.options = this.elements = this.cache = this.timers =
            this.plugins = this.mouse = NULL;

        // Delete epoxsed API object
        delete QTIP.api[this.id];
    }

    // If an immediate destory is needed
    if((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
        this.tooltip.one('tooltiphidden', $.proxy(process, this));
        !this.triggering && this.hide();
    }

    // If we're not in the process of hiding... process
    else { process.call(this); }

    return this.target;
};

;function invalidOpt(a) {
    return a === NULL || $.type(a) !== 'object';
}

function invalidContent(c) {
    return !( $.isFunction(c) || (c && c.attr) || c.length || ($.type(c) === 'object' && (c.jquery || c.then) ));
}

// Option object sanitizer
function sanitizeOptions(opts) {
    var content, text, ajax, once;

    if(invalidOpt(opts)) { return FALSE; }

    if(invalidOpt(opts.metadata)) {
        opts.metadata = { type: opts.metadata };
    }

    if('content' in opts) {
        content = opts.content;

        if(invalidOpt(content) || content.jquery || content.done) {
            content = opts.content = {
                text: (text = invalidContent(content) ? FALSE : content)
            };
        }
        else { text = content.text; }

        // DEPRECATED - Old content.ajax plugin functionality
        // Converts it into the proper Deferred syntax
        if('ajax' in content) {
            ajax = content.ajax;
            once = ajax && ajax.once !== FALSE;
            delete content.ajax;

            content.text = function(event, api) {
                var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

                deferred = $.ajax(
                    $.extend({}, ajax, { context: api })
                )
                .then(ajax.success, NULL, ajax.error)
                .then(function(content) {
                    if(content && once) { api.set('content.text', content); }
                    return content;
                },
                function(xhr, status, error) {
                    if(api.destroyed || xhr.status === 0) { return; }
                    api.set('content.text', status + ': ' + error);
                });

                return !once ? (api.set('content.text', loading), deferred) : loading;
            };
        }

        if('title' in content) {
            if(!invalidOpt(content.title)) {
                content.button = content.title.button;
                content.title = content.title.text;
            }

            if(invalidContent(content.title || FALSE)) {
                content.title = FALSE;
            }
        }
    }

    if('position' in opts && invalidOpt(opts.position)) {
        opts.position = { my: opts.position, at: opts.position };
    }

    if('show' in opts && invalidOpt(opts.show)) {
        opts.show = opts.show.jquery ? { target: opts.show } :
            opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
    }

    if('hide' in opts && invalidOpt(opts.hide)) {
        opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
    }

    if('style' in opts && invalidOpt(opts.style)) {
        opts.style = { classes: opts.style };
    }

    // Sanitize plugin options
    $.each(PLUGINS, function() {
        this.sanitize && this.sanitize(opts);
    });

    return opts;
}

// Setup builtin .set() option checks
CHECKS = PROTOTYPE.checks = {
    builtin: {
        // Core checks
        '^id$': function(obj, o, v, prev) {
            var id = v === TRUE ? QTIP.nextid : v,
                new_id = NAMESPACE + '-' + id;

            if(id !== FALSE && id.length > 0 && !$('#'+new_id).length) {
                this._id = new_id;

                if(this.rendered) {
                    this.tooltip[0].id = this._id;
                    this.elements.content[0].id = this._id + '-content';
                    this.elements.title[0].id = this._id + '-title';
                }
            }
            else { obj[o] = prev; }
        },
        '^prerender': function(obj, o, v) {
            v && !this.rendered && this.render(this.options.show.ready);
        },

        // Content checks
        '^content.text$': function(obj, o, v) {
            this._updateContent(v);
        },
        '^content.attr$': function(obj, o, v, prev) {
            if(this.options.content.text === this.target.attr(prev)) {
                this._updateContent( this.target.attr(v) );
            }
        },
        '^content.title$': function(obj, o, v) {
            // Remove title if content is null
            if(!v) { return this._removeTitle(); }

            // If title isn't already created, create it now and update
            v && !this.elements.title && this._createTitle();
            this._updateTitle(v);
        },
        '^content.button$': function(obj, o, v) {
            this._updateButton(v);
        },
        '^content.title.(text|button)$': function(obj, o, v) {
            this.set('content.'+o, v); // Backwards title.text/button compat
        },

        // Position checks
        '^position.(my|at)$': function(obj, o, v){
            'string' === typeof v && (obj[o] = new CORNER(v, o === 'at'));
        },
        '^position.container$': function(obj, o, v){
            this.rendered && this.tooltip.appendTo(v);
        },

        // Show checks
        '^show.ready$': function(obj, o, v) {
            v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
        },

        // Style checks
        '^style.classes$': function(obj, o, v, p) {
            this.rendered && this.tooltip.removeClass(p).addClass(v);
        },
        '^style.(width|height)': function(obj, o, v) {
            this.rendered && this.tooltip.css(o, v);
        },
        '^style.widget|content.title': function() {
            this.rendered && this._setWidget();
        },
        '^style.def': function(obj, o, v) {
            this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
        },

        // Events check
        '^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
            this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
        },

        // Properties which require event reassignment
        '^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
            if(!this.rendered) { return; }

            // Set tracking flag
            var posOptions = this.options.position;
            this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

            // Reassign events
            this._unassignEvents();
            this._assignEvents();
        }
    }
};

// Dot notation converter
function convertNotation(options, notation) {
    var i = 0, obj, option = options,

    // Split notation into array
    levels = notation.split('.');

    // Loop through
    while( option = option[ levels[i++] ] ) {
        if(i < levels.length) { obj = option; }
    }

    return [obj || options, levels.pop()];
}

PROTOTYPE.get = function(notation) {
    if(this.destroyed) { return this; }

    var o = convertNotation(this.options, notation.toLowerCase()),
        result = o[0][ o[1] ];

    return result.precedance ? result.string() : result;
};

function setCallback(notation, args) {
    var category, rule, match;

    for(category in this.checks) {
        for(rule in this.checks[category]) {
            if(match = (new RegExp(rule, 'i')).exec(notation)) {
                args.push(match);

                if(category === 'builtin' || this.plugins[category]) {
                    this.checks[category][rule].apply(
                        this.plugins[category] || this, args
                    );
                }
            }
        }
    }
}

var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
    rrender = /^prerender|show\.ready/i;

PROTOTYPE.set = function(option, value) {
    if(this.destroyed) { return this; }

    var rendered = this.rendered,
        reposition = FALSE,
        options = this.options,
        checks = this.checks,
        name;

    // Convert singular option/value pair into object form
    if('string' === typeof option) {
        name = option; option = {}; option[name] = value;
    }
    else { option = $.extend({}, option); }

    // Set all of the defined options to their new values
    $.each(option, function(notation, value) {
        if(rendered && rrender.test(notation)) {
            delete option[notation]; return;
        }

        // Set new obj value
        var obj = convertNotation(options, notation.toLowerCase()), previous;
        previous = obj[0][ obj[1] ];
        obj[0][ obj[1] ] = value && value.nodeType ? $(value) : value;

        // Also check if we need to reposition
        reposition = rmove.test(notation) || reposition;

        // Set the new params for the callback
        option[notation] = [obj[0], obj[1], value, previous];
    });

    // Re-sanitize options
    sanitizeOptions(options);

    /*
     * Execute any valid callbacks for the set options
     * Also set positioning flag so we don't get loads of redundant repositioning calls.
     */
    this.positioning = TRUE;
    $.each(option, $.proxy(setCallback, this));
    this.positioning = FALSE;

    // Update position if needed
    if(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
        this.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );
    }

    return this;
};

;PROTOTYPE._update = function(content, element, reposition) {
    var self = this,
        cache = this.cache;

    // Make sure tooltip is rendered and content is defined. If not return
    if(!this.rendered || !content) { return FALSE; }

    // Use function to parse content
    if($.isFunction(content)) {
        content = content.call(this.elements.target, cache.event, this) || '';
    }

    // Handle deferred content
    if($.isFunction(content.then)) {
        cache.waiting = TRUE;
        return content.then(function(c) {
            cache.waiting = FALSE;
            return self._update(c, element);
        }, NULL, function(e) {
            return self._update(e, element);
        });
    }

    // If content is null... return false
    if(content === FALSE || (!content && content !== '')) { return FALSE; }

    // Append new content if its a DOM array and show it if hidden
    if(content.jquery && content.length > 0) {
        element.empty().append(
            content.css({ display: 'block', visibility: 'visible' })
        );
    }

    // Content is a regular string, insert the new content
    else { element.html(content); }

    // Wait for content to be loaded, and reposition
    return this._waitForContent(element).then(function(images) {
        if(images.images && images.images.length && self.rendered && self.tooltip[0].offsetWidth > 0) {
            self.reposition(cache.event, !images.length);
        }
    });
};

PROTOTYPE._waitForContent = function(element) {
    var cache = this.cache;

    // Set flag
    cache.waiting = TRUE;

    // If imagesLoaded is included, ensure images have loaded and return promise
    return ( $.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([]) )
        .done(function() { cache.waiting = FALSE; })
        .promise();
};

PROTOTYPE._updateContent = function(content, reposition) {
    this._update(content, this.elements.content, reposition);
};

PROTOTYPE._updateTitle = function(content, reposition) {
    if(this._update(content, this.elements.title, reposition) === FALSE) {
        this._removeTitle(FALSE);
    }
};

PROTOTYPE._createTitle = function()
{
    var elements = this.elements,
        id = this._id+'-title';

    // Destroy previous title element, if present
    if(elements.titlebar) { this._removeTitle(); }

    // Create title bar and title elements
    elements.titlebar = $('<div />', {
        'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
    })
    .append(
        elements.title = $('<div />', {
            'id': id,
            'class': NAMESPACE + '-title',
            'aria-atomic': TRUE
        })
    )
    .insertBefore(elements.content)

    // Button-specific events
    .delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {
        $(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
    })
    .delegate('.qtip-close', 'mouseover mouseout', function(event){
        $(this).toggleClass('ui-state-hover', event.type === 'mouseover');
    });

    // Create button if enabled
    if(this.options.content.button) { this._createButton(); }
};

PROTOTYPE._removeTitle = function(reposition)
{
    var elements = this.elements;

    if(elements.title) {
        elements.titlebar.remove();
        elements.titlebar = elements.title = elements.button = NULL;

        // Reposition if enabled
        if(reposition !== FALSE) { this.reposition(); }
    }
};

;PROTOTYPE.reposition = function(event, effect) {
    if(!this.rendered || this.positioning || this.destroyed) { return this; }

    // Set positioning flag
    this.positioning = TRUE;

    var cache = this.cache,
        tooltip = this.tooltip,
        posOptions = this.options.position,
        target = posOptions.target,
        my = posOptions.my,
        at = posOptions.at,
        viewport = posOptions.viewport,
        container = posOptions.container,
        adjust = posOptions.adjust,
        method = adjust.method.split(' '),
        tooltipWidth = tooltip.outerWidth(FALSE),
        tooltipHeight = tooltip.outerHeight(FALSE),
        targetWidth = 0,
        targetHeight = 0,
        type = tooltip.css('position'),
        position = { left: 0, top: 0 },
        visible = tooltip[0].offsetWidth > 0,
        isScroll = event && event.type === 'scroll',
        win = $(window),
        doc = container[0].ownerDocument,
        mouse = this.mouse,
        pluginCalculations, offset;

    // Check if absolute position was passed
    if($.isArray(target) && target.length === 2) {
        // Force left top and set position
        at = { x: LEFT, y: TOP };
        position = { left: target[0], top: target[1] };
    }

    // Check if mouse was the target
    else if(target === 'mouse') {
        // Force left top to allow flipping
        at = { x: LEFT, y: TOP };

        // Use the cached mouse coordinates if available, or passed event has no coordinates
        if(mouse && mouse.pageX && (adjust.mouse || !event || !event.pageX) ) {
            event = mouse;
        }

        // If the passed event has no coordinates (such as a scroll event)
        else if(!event || !event.pageX) {
            // Use the mouse origin that caused the show event, if distance hiding is enabled
            if((!adjust.mouse || this.options.show.distance) && cache.origin && cache.origin.pageX) {
                event =  cache.origin;
            }

            // Use cached event for resize/scroll events
            else if(!event || (event && (event.type === 'resize' || event.type === 'scroll'))) {
                event = cache.event;
            }
        }

        // Calculate body and container offset and take them into account below
        if(type !== 'static') { position = container.offset(); }
        if(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
            offset = $(document.body).offset();
        }

        // Use event coordinates for position
        position = {
            left: event.pageX - position.left + (offset && offset.left || 0),
            top: event.pageY - position.top + (offset && offset.top || 0)
        };

        // Scroll events are a pain, some browsers
        if(adjust.mouse && isScroll && mouse) {
            position.left -= (mouse.scrollX || 0) - win.scrollLeft();
            position.top -= (mouse.scrollY || 0) - win.scrollTop();
        }
    }

    // Target wasn't mouse or absolute...
    else {
        // Check if event targetting is being used
        if(target === 'event') {
            if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
                cache.target = $(event.target);
            }
            else if(!event.target) {
                cache.target = this.elements.target;
            }
        }
        else if(target !== 'event'){
            cache.target = $(target.jquery ? target : this.elements.target);
        }
        target = cache.target;

        // Parse the target into a jQuery object and make sure there's an element present
        target = $(target).eq(0);
        if(target.length === 0) { return this; }

        // Check if window or document is the target
        else if(target[0] === document || target[0] === window) {
            targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
            targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

            if(target[0] === window) {
                position = {
                    top: (viewport || target).scrollTop(),
                    left: (viewport || target).scrollLeft()
                };
            }
        }

        // Check if the target is an <AREA> element
        else if(PLUGINS.imagemap && target.is('area')) {
            pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
        }

        // Check if the target is an SVG element
        else if(PLUGINS.svg && target && target[0].ownerSVGElement) {
            pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
        }

        // Otherwise use regular jQuery methods
        else {
            targetWidth = target.outerWidth(FALSE);
            targetHeight = target.outerHeight(FALSE);
            position = target.offset();
        }

        // Parse returned plugin values into proper variables
        if(pluginCalculations) {
            targetWidth = pluginCalculations.width;
            targetHeight = pluginCalculations.height;
            offset = pluginCalculations.offset;
            position = pluginCalculations.position;
        }

        // Adjust position to take into account offset parents
        position = this.reposition.offset(target, position, container);

        // Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
        if((BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1) ||
            (BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33) ||
            (!BROWSER.iOS && type === 'fixed')
        ){
            position.left -= win.scrollLeft();
            position.top -= win.scrollTop();
        }

        // Adjust position relative to target
        if(!pluginCalculations || (pluginCalculations && pluginCalculations.adjustable !== FALSE)) {
            position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
            position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
        }
    }

    // Adjust position relative to tooltip
    position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
    position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

    // Use viewport adjustment plugin if enabled
    if(PLUGINS.viewport) {
        position.adjusted = PLUGINS.viewport(
            this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
        );

        // Apply offsets supplied by positioning plugin (if used)
        if(offset && position.adjusted.left) { position.left += offset.left; }
        if(offset && position.adjusted.top) {  position.top += offset.top; }
    }

    // Viewport adjustment is disabled, set values to zero
    else { position.adjusted = { left: 0, top: 0 }; }

    // tooltipmove event
    if(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
    delete position.adjusted;

    // If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
    if(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
        tooltip.css(position);
    }

    // Use custom function if provided
    else if($.isFunction(posOptions.effect)) {
        posOptions.effect.call(tooltip, this, $.extend({}, position));
        tooltip.queue(function(next) {
            // Reset attributes to avoid cross-browser rendering bugs
            $(this).css({ opacity: '', height: '' });
            if(BROWSER.ie) { this.style.removeAttribute('filter'); }

            next();
        });
    }

    // Set positioning flag
    this.positioning = FALSE;

    return this;
};

// Custom (more correct for qTip!) offset calculator
PROTOTYPE.reposition.offset = function(elem, pos, container) {
    if(!container[0]) { return pos; }

    var ownerDocument = $(elem[0].ownerDocument),
        quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
        parent = container[0],
        scrolled, position, parentOffset, overflow;

    function scroll(e, i) {
        pos.left += i * e.scrollLeft();
        pos.top += i * e.scrollTop();
    }

    // Compensate for non-static containers offset
    do {
        if((position = $.css(parent, 'position')) !== 'static') {
            if(position === 'fixed') {
                parentOffset = parent.getBoundingClientRect();
                scroll(ownerDocument, -1);
            }
            else {
                parentOffset = $(parent).position();
                parentOffset.left += (parseFloat($.css(parent, 'borderLeftWidth')) || 0);
                parentOffset.top += (parseFloat($.css(parent, 'borderTopWidth')) || 0);
            }

            pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
            pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

            // If this is the first parent element with an overflow of "scroll" or "auto", store it
            if(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
        }
    }
    while((parent = parent.offsetParent));

    // Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
    if(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
        scroll(scrolled, 1);
    }

    return pos;
};

// Corner class
var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
    corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
    this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
    this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
    this.forceY = !!forceY;

    var f = corner.charAt(0);
    this.precedance = (f === 't' || f === 'b' ? Y : X);
}).prototype;

C.invert = function(z, center) {
    this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
};

C.string = function() {
    var x = this.x, y = this.y;
    return x === y ? x : this.precedance === Y || (this.forceY && y !== 'center') ? y+' '+x : x+' '+y;
};

C.abbrev = function() {
    var result = this.string().split(' ');
    return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
};

C.clone = function() {
    return new CORNER( this.string(), this.forceY );
};;
PROTOTYPE.toggle = function(state, event) {
    var cache = this.cache,
        options = this.options,
        tooltip = this.tooltip;

    // Try to prevent flickering when tooltip overlaps show element
    if(event) {
        if((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&
            options.show.target.add(event.target).length === options.show.target.length &&
            tooltip.has(event.relatedTarget).length) {
            return this;
        }

        // Cache event
        cache.event = cloneEvent(event);
    }

    // If we're currently waiting and we've just hidden... stop it
    this.waiting && !state && (this.hiddenDuringWait = TRUE);

    // Render the tooltip if showing and it isn't already
    if(!this.rendered) { return state ? this.render(1) : this; }
    else if(this.destroyed || this.disabled) { return this; }

    var type = state ? 'show' : 'hide',
        opts = this.options[type],
        otherOpts = this.options[ !state ? 'show' : 'hide' ],
        posOptions = this.options.position,
        contentOptions = this.options.content,
        width = this.tooltip.css('width'),
        visible = this.tooltip.is(':visible'),
        animate = state || opts.target.length === 1,
        sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
        identicalState, allow, showEvent, delay, after;

    // Detect state if valid one isn't provided
    if((typeof state).search('boolean|number')) { state = !visible; }

    // Check if the tooltip is in an identical state to the new would-be state
    identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

    // Fire tooltip(show/hide) event and check if destroyed
    allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

    // Check to make sure the tooltip wasn't destroyed in the callback
    if(this.destroyed) { return this; }

    // If the user didn't stop the method prematurely and we're showing the tooltip, focus it
    if(allow !== FALSE && state) { this.focus(event); }

    // If the state hasn't changed or the user stopped it, return early
    if(!allow || identicalState) { return this; }

    // Set ARIA hidden attribute
    $.attr(tooltip[0], 'aria-hidden', !!!state);

    // Execute state specific properties
    if(state) {
        // Store show origin coordinates
        cache.origin = cloneEvent(this.mouse);

        // Update tooltip content & title if it's a dynamic function
        if($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
        if($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

        // Cache mousemove events for positioning purposes (if not already tracking)
        if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
            $(document).bind('mousemove.'+NAMESPACE, this._storeMouse);
            trackingBound = TRUE;
        }

        // Update the tooltip position (set width first to prevent viewport/max-width issues)
        if(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
        this.reposition(event, arguments[2]);
        if(!width) { tooltip.css('width', ''); }

        // Hide other tooltips if tooltip is solo
        if(!!opts.solo) {
            (typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
                .not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));
        }
    }
    else {
        // Clear show timer if we're hiding
        clearTimeout(this.timers.show);

        // Remove cached origin on hide
        delete cache.origin;

        // Remove mouse tracking event if not needed (all tracking qTips are hidden)
        if(trackingBound && !$(SELECTOR+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
            $(document).unbind('mousemove.'+NAMESPACE);
            trackingBound = FALSE;
        }

        // Blur the tooltip
        this.blur(event);
    }

    // Define post-animation, state specific properties
    after = $.proxy(function() {
        if(state) {
            // Prevent antialias from disappearing in IE by removing filter
            if(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

            // Remove overflow setting to prevent tip bugs
            tooltip.css('overflow', '');

            // Autofocus elements if enabled
            if('string' === typeof opts.autofocus) {
                $(this.options.show.autofocus, tooltip).focus();
            }

            // If set, hide tooltip when inactive for delay period
            this.options.show.target.trigger('qtip-'+this.id+'-inactive');
        }
        else {
            // Reset CSS states
            tooltip.css({
                display: '',
                visibility: '',
                opacity: '',
                left: '',
                top: ''
            });
        }

        // tooltipvisible/tooltiphidden events
        this._trigger(state ? 'visible' : 'hidden');
    }, this);

    // If no effect type is supplied, use a simple toggle
    if(opts.effect === FALSE || animate === FALSE) {
        tooltip[ type ]();
        after();
    }

    // Use custom function if provided
    else if($.isFunction(opts.effect)) {
        tooltip.stop(1, 1);
        opts.effect.call(tooltip, this);
        tooltip.queue('fx', function(n) {
            after(); n();
        });
    }

    // Use basic fade function by default
    else { tooltip.fadeTo(90, state ? 1 : 0, after); }

    // If inactive hide method is set, active it
    if(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }

    return this;
};

PROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };

PROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };

;PROTOTYPE.focus = function(event) {
    if(!this.rendered || this.destroyed) { return this; }

    var qtips = $(SELECTOR),
        tooltip = this.tooltip,
        curIndex = parseInt(tooltip[0].style.zIndex, 10),
        newIndex = QTIP.zindex + qtips.length,
        focusedElem;

    // Only update the z-index if it has changed and tooltip is not already focused
    if(!tooltip.hasClass(CLASS_FOCUS)) {
        // tooltipfocus event
        if(this._trigger('focus', [newIndex], event)) {
            // Only update z-index's if they've changed
            if(curIndex !== newIndex) {
                // Reduce our z-index's and keep them properly ordered
                qtips.each(function() {
                    if(this.style.zIndex > curIndex) {
                        this.style.zIndex = this.style.zIndex - 1;
                    }
                });

                // Fire blur event for focused tooltip
                qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
            }

            // Set the new z-index
            tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
        }
    }

    return this;
};

PROTOTYPE.blur = function(event) {
    if(!this.rendered || this.destroyed) { return this; }

    // Set focused status to FALSE
    this.tooltip.removeClass(CLASS_FOCUS);

    // tooltipblur event
    this._trigger('blur', [ this.tooltip.css('zIndex') ], event);

    return this;
};

;PROTOTYPE.disable = function(state) {
    if(this.destroyed) { return this; }

    // If 'toggle' is passed, toggle the current state
    if(state === 'toggle') {
        state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
    }

    // Disable if no state passed
    else if('boolean' !== typeof state) {
        state = TRUE;
    }

    if(this.rendered) {
        this.tooltip.toggleClass(CLASS_DISABLED, state)
            .attr('aria-disabled', state);
    }

    this.disabled = !!state;

    return this;
};

PROTOTYPE.enable = function() { return this.disable(FALSE); };

;PROTOTYPE._createButton = function()
{
    var self = this,
        elements = this.elements,
        tooltip = elements.tooltip,
        button = this.options.content.button,
        isString = typeof button === 'string',
        close = isString ? button : 'Close tooltip';

    if(elements.button) { elements.button.remove(); }

    // Use custom button if one was supplied by user, else use default
    if(button.jquery) {
        elements.button = button;
    }
    else {
        elements.button = $('<a />', {
            'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),
            'title': close,
            'aria-label': close
        })
        .prepend(
            $('<span />', {
                'class': 'ui-icon ui-icon-close',
                'html': '&times;'
            })
        );
    }

    // Create button and setup attributes
    elements.button.appendTo(elements.titlebar || tooltip)
        .attr('role', 'button')
        .click(function(event) {
            if(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
            return FALSE;
        });
};

PROTOTYPE._updateButton = function(button)
{
    // Make sure tooltip is rendered and if not, return
    if(!this.rendered) { return FALSE; }

    var elem = this.elements.button;
    if(button) { this._createButton(); }
    else { elem.remove(); }
};

;// Widget class creator
function createWidgetClass(cls) {
    return WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');
}

// Widget class setter method
PROTOTYPE._setWidget = function()
{
    var on = this.options.style.widget,
        elements = this.elements,
        tooltip = elements.tooltip,
        disabled = tooltip.hasClass(CLASS_DISABLED);

    tooltip.removeClass(CLASS_DISABLED);
    CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
    tooltip.toggleClass(CLASS_DISABLED, disabled);

    tooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);

    if(elements.content) {
        elements.content.toggleClass( createWidgetClass('content'), on);
    }
    if(elements.titlebar) {
        elements.titlebar.toggleClass( createWidgetClass('header'), on);
    }
    if(elements.button) {
        elements.button.toggleClass(NAMESPACE+'-icon', !on);
    }
};;function cloneEvent(event) {
    return event && {
        type: event.type,
        pageX: event.pageX,
        pageY: event.pageY,
        target: event.target,
        relatedTarget: event.relatedTarget,
        scrollX: event.scrollX || window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft,
        scrollY: event.scrollY || window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop
    } || {};
}

function delay(callback, duration) {
    // If tooltip has displayed, start hide timer
    if(duration > 0) {
        return setTimeout(
            $.proxy(callback, this), duration
        );
    }
    else{ callback.call(this); }
}

function showMethod(event) {
    if(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

    // Clear hide timers
    clearTimeout(this.timers.show);
    clearTimeout(this.timers.hide);

    // Start show timer
    this.timers.show = delay.call(this,
        function() { this.toggle(TRUE, event); },
        this.options.show.delay
    );
}

function hideMethod(event) {
    if(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

    // Check if new target was actually the tooltip element
    var relatedTarget = $(event.relatedTarget),
        ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
        ontoTarget = relatedTarget[0] === this.options.show.target[0];

    // Clear timers and stop animation queue
    clearTimeout(this.timers.show);
    clearTimeout(this.timers.hide);

    // Prevent hiding if tooltip is fixed and event target is the tooltip.
    // Or if mouse positioning is enabled and cursor momentarily overlaps
    if(this !== relatedTarget[0] &&
        (this.options.position.target === 'mouse' && ontoTooltip) ||
        (this.options.hide.fixed && (
            (/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
        ))
    {
        try {
            event.preventDefault();
            event.stopImmediatePropagation();
        } catch(e) {}

        return;
    }

    // If tooltip has displayed, start hide timer
    this.timers.hide = delay.call(this,
        function() { this.toggle(FALSE, event); },
        this.options.hide.delay,
        this
    );
}

function inactiveMethod(event) {
    if(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return FALSE; }

    // Clear timer
    clearTimeout(this.timers.inactive);

    this.timers.inactive = delay.call(this,
        function(){ this.hide(event); },
        this.options.hide.inactive
    );
}

function repositionMethod(event) {
    if(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
}

// Store mouse coordinates
PROTOTYPE._storeMouse = function(event) {
    (this.mouse = cloneEvent(event)).type = 'mousemove';
};

// Bind events
PROTOTYPE._bind = function(targets, events, method, suffix, context) {
    var ns = '.' + this._id + (suffix ? '-'+suffix : '');
    events.length && $(targets).bind(
        (events.split ? events : events.join(ns + ' ')) + ns,
        $.proxy(method, context || this)
    );
};
PROTOTYPE._unbind = function(targets, suffix) {
    $(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));
};

// Apply common event handlers using delegate (avoids excessive .bind calls!)
var ns = '.'+NAMESPACE;
function delegate(selector, events, method) {
    $(document.body).delegate(selector,
        (events.split ? events : events.join(ns + ' ')) + ns,
        function() {
            var api = QTIP.api[ $.attr(this, ATTR_ID) ];
            api && !api.disabled && method.apply(api, arguments);
        }
    );
}

$(function() {
    delegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {
        var state = event.type === 'mouseenter',
            tooltip = $(event.currentTarget),
            target = $(event.relatedTarget || event.target),
            options = this.options;

        // On mouseenter...
        if(state) {
            // Focus the tooltip on mouseenter (z-index stacking)
            this.focus(event);

            // Clear hide timer on tooltip hover to prevent it from closing
            tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
        }

        // On mouseleave...
        else {
            // Hide when we leave the tooltip and not onto the show target (if a hide event is set)
            if(options.position.target === 'mouse' && options.hide.event &&
                options.show.target && !target.closest(options.show.target[0]).length) {
                this.hide(event);
            }
        }

        // Add hover class
        tooltip.toggleClass(CLASS_HOVER, state);
    });

    // Define events which reset the 'inactive' event handler
    delegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);
});

// Event trigger
PROTOTYPE._trigger = function(type, args, event) {
    var callback = $.Event('tooltip'+type);
    callback.originalEvent = (event && $.extend({}, event)) || this.cache.event || NULL;

    this.triggering = type;
    this.tooltip.trigger(callback, [this].concat(args || []));
    this.triggering = FALSE;

    return !callback.isDefaultPrevented();
};

PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod) {
    // If hide and show targets are the same...
    if(hideTarget.add(showTarget).length === hideTarget.length) {
        var toggleEvents = [];

        // Filter identical show/hide events
        hideEvents = $.map(hideEvents, function(type) {
            var showIndex = $.inArray(type, showEvents);

            // Both events are identical, remove from both hide and show events
            // and append to toggleEvents
            if(showIndex > -1) {
                toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );
                return;
            }

            return type;
        });

        // Toggle events are special case of identical show/hide events, which happen in sequence
        toggleEvents.length && this._bind(showTarget, toggleEvents, function(event) {
            var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
            (state ? hideMethod : showMethod).call(this, event);
        });
    }

    // Apply show/hide/toggle events
    this._bind(showTarget, showEvents, showMethod);
    this._bind(hideTarget, hideEvents, hideMethod);
};

PROTOTYPE._assignInitialEvents = function(event) {
    var options = this.options,
        showTarget = options.show.target,
        hideTarget = options.hide.target,
        showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
        hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

    /*
     * Make sure hoverIntent functions properly by using mouseleave as a hide event if
     * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
     */
    if(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
        hideEvents.push('mouseleave');
    }

    /*
     * Also make sure initial mouse targetting works correctly by caching mousemove coords
     * on show targets before the tooltip has rendered. Also set onTarget when triggered to
     * keep mouse tracking working.
     */
    this._bind(showTarget, 'mousemove', function(event) {
        this._storeMouse(event);
        this.cache.onTarget = TRUE;
    });

    // Define hoverIntent function
    function hoverIntent(event) {
        // Only continue if tooltip isn't disabled
        if(this.disabled || this.destroyed) { return FALSE; }

        // Cache the event data
        this.cache.event = cloneEvent(event);
        this.cache.target = event ? $(event.target) : [undefined];

        // Start the event sequence
        clearTimeout(this.timers.show);
        this.timers.show = delay.call(this,
            function() { this.render(typeof event === 'object' || options.show.ready); },
            options.show.delay
        );
    }

    // Filter and bind events
    this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
        clearTimeout(this.timers.show);
    });

    // Prerendering is enabled, create tooltip now
    if(options.show.ready || options.prerender) { hoverIntent.call(this, event); }
};

// Event assignment method
PROTOTYPE._assignEvents = function() {
    var self = this,
        options = this.options,
        posOptions = options.position,

        tooltip = this.tooltip,
        showTarget = options.show.target,
        hideTarget = options.hide.target,
        containerTarget = posOptions.container,
        viewportTarget = posOptions.viewport,
        documentTarget = $(document),
        bodyTarget = $(document.body),
        windowTarget = $(window),

        showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
        hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


    // Assign passed event callbacks
    $.each(options.events, function(name, callback) {
        self._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);
    });

    // Hide tooltips when leaving current window/frame (but not select/option elements)
    if(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
        this._bind(documentTarget, ['mouseout', 'blur'], function(event) {
            if(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
                this.hide(event);
            }
        });
    }

    // Enable hide.fixed by adding appropriate class
    if(options.hide.fixed) {
        hideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );
    }

    /*
     * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
     * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
     */
    else if(/mouse(over|enter)/i.test(options.show.event)) {
        this._bind(hideTarget, 'mouseleave', function() {
            clearTimeout(this.timers.show);
        });
    }

    // Hide tooltip on document mousedown if unfocus events are enabled
    if(('' + options.hide.event).indexOf('unfocus') > -1) {
        this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {
            var elem = $(event.target),
                enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
                isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

            if(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
                !this.target.has(elem[0]).length && enabled
            ) {
                this.hide(event);
            }
        });
    }

    // Check if the tooltip hides when inactive
    if('number' === typeof options.hide.inactive) {
        // Bind inactive method to show target(s) as a custom event
        this._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod);

        // Define events which reset the 'inactive' event handler
        this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod, '-inactive');
    }

    // Filter and bind events
    this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

    // Mouse movement bindings
    this._bind(showTarget.add(tooltip), 'mousemove', function(event) {
        // Check if the tooltip hides when mouse is moved a certain distance
        if('number' === typeof options.hide.distance) {
            var origin = this.cache.origin || {},
                limit = this.options.hide.distance,
                abs = Math.abs;

            // Check if the movement has gone beyond the limit, and hide it if so
            if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
                this.hide(event);
            }
        }

        // Cache mousemove coords on show targets
        this._storeMouse(event);
    });

    // Mouse positioning events
    if(posOptions.target === 'mouse') {
        // If mouse adjustment is on...
        if(posOptions.adjust.mouse) {
            // Apply a mouseleave event so we don't get problems with overlapping
            if(options.hide.event) {
                // Track if we're on the target or not
                this._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {
                    this.cache.onTarget = event.type === 'mouseenter';
                });
            }

            // Update tooltip position on mousemove
            this._bind(documentTarget, 'mousemove', function(event) {
                // Update the tooltip position only if the tooltip is visible and adjustment is enabled
                if(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
                    this.reposition(event);
                }
            });
        }
    }

    // Adjust positions of the tooltip on window resize if enabled
    if(posOptions.adjust.resize || viewportTarget.length) {
        this._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );
    }

    // Adjust tooltip position on scroll of the window or viewport element if present
    if(posOptions.adjust.scroll) {
        this._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );
    }
};

// Un-assignment method
PROTOTYPE._unassignEvents = function() {
    var targets = [
        this.options.show.target[0],
        this.options.hide.target[0],
        this.rendered && this.tooltip[0],
        this.options.position.container[0],
        this.options.position.viewport[0],
        this.options.position.container.closest('html')[0], // unfocus
        window,
        document
    ];

    this._unbind($([]).pushStack( $.grep(targets, function(i) {
        return typeof i === 'object';
    })));
};

;// Initialization method
function init(elem, id, opts) {
    var obj, posOptions, attr, config, title,

    // Setup element references
    docBody = $(document.body),

    // Use document body instead of document element if needed
    newTarget = elem[0] === document ? docBody : elem,

    // Grab metadata from element if plugin is present
    metadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,

    // If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
    metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

    // Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
    html5 = elem.data(opts.metadata.name || 'qtipopts');

    // If we don't get an object returned attempt to parse it manualyl without parseJSON
    try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; } catch(e) {}

    // Merge in and sanitize metadata
    config = $.extend(TRUE, {}, QTIP.defaults, opts,
        typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
        sanitizeOptions(metadata5 || metadata));

    // Re-grab our positioning options now we've merged our metadata and set id to passed value
    posOptions = config.position;
    config.id = id;

    // Setup missing content if none is detected
    if('boolean' === typeof config.content.text) {
        attr = elem.attr(config.content.attr);

        // Grab from supplied attribute if available
        if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

        // No valid content was found, abort render
        else { return FALSE; }
    }

    // Setup target options
    if(!posOptions.container.length) { posOptions.container = docBody; }
    if(posOptions.target === FALSE) { posOptions.target = newTarget; }
    if(config.show.target === FALSE) { config.show.target = newTarget; }
    if(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
    if(config.hide.target === FALSE) { config.hide.target = newTarget; }
    if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

    // Ensure we only use a single container
    posOptions.container = posOptions.container.eq(0);

    // Convert position corner values into x and y strings
    posOptions.at = new CORNER(posOptions.at, TRUE);
    posOptions.my = new CORNER(posOptions.my);

    // Destroy previous tooltip if overwrite is enabled, or skip element if not
    if(elem.data(NAMESPACE)) {
        if(config.overwrite) {
            elem.qtip('destroy', true);
        }
        else if(config.overwrite === FALSE) {
            return FALSE;
        }
    }

    // Add has-qtip attribute
    elem.attr(ATTR_HAS, id);

    // Remove title attribute and store it if present
    if(config.suppress && (title = elem.attr('title'))) {
        // Final attr call fixes event delegatiom and IE default tooltip showing problem
        elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
    }

    // Initialize the tooltip and add API reference
    obj = new QTip(elem, config, id, !!attr);
    elem.data(NAMESPACE, obj);

    // Catch remove/removeqtip events on target element to destroy redundant tooltip
    elem.one('remove.qtip-'+id+' removeqtip.qtip-'+id, function() {
        var api; if((api = $(this).data(NAMESPACE))) { api.destroy(true); }
    });

    return obj;
}

// jQuery $.fn extension method
QTIP = $.fn.qtip = function(options, notation, newValue)
{
    var command = ('' + options).toLowerCase(), // Parse command
        returned = NULL,
        args = $.makeArray(arguments).slice(1),
        event = args[args.length - 1],
        opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

    // Check for API request
    if((!arguments.length && opts) || command === 'api') {
        return opts;
    }

    // Execute API command if present
    else if('string' === typeof options) {
        this.each(function() {
            var api = $.data(this, NAMESPACE);
            if(!api) { return TRUE; }

            // Cache the event if possible
            if(event && event.timeStamp) { api.cache.event = event; }

            // Check for specific API commands
            if(notation && (command === 'option' || command === 'options')) {
                if(newValue !== undefined || $.isPlainObject(notation)) {
                    api.set(notation, newValue);
                }
                else {
                    returned = api.get(notation);
                    return FALSE;
                }
            }

            // Execute API command
            else if(api[command]) {
                api[command].apply(api, args);
            }
        });

        return returned !== NULL ? returned : this;
    }

    // No API commands. validate provided options and setup qTips
    else if('object' === typeof options || !arguments.length) {
        // Sanitize options first
        opts = sanitizeOptions($.extend(TRUE, {}, options));

        return this.each(function(i) {
            var api, id;

            // Find next available ID, or use custom ID if provided
            id = $.isArray(opts.id) ? opts.id[i] : opts.id;
            id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

            // Initialize the qTip and re-grab newly sanitized options
            api = init($(this), id, opts);
            if(api === FALSE) { return TRUE; }
            else { QTIP.api[id] = api; }

            // Initialize plugins
            $.each(PLUGINS, function() {
                if(this.initialize === 'initialize') { this(api); }
            });

            // Assign initial pre-render events
            api._assignInitialEvents(event);
        });
    }
};

// Expose class
$.qtip = QTip;

// Populated in render method
QTIP.api = {};
;$.each({
    /* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
    attr: function(attr, val) {
        if(this.length) {
            var self = this[0],
                title = 'title',
                api = $.data(self, 'qtip');

            if(attr === title && api && 'object' === typeof api && api.options.suppress) {
                if(arguments.length < 2) {
                    return $.attr(self, oldtitle);
                }

                // If qTip is rendered and title was originally used as content, update it
                if(api && api.options.content.attr === title && api.cache.attr) {
                    api.set('content.text', val);
                }

                // Use the regular attr method to set, then cache the result
                return this.attr(oldtitle, val);
            }
        }

        return $.fn['attr'+replaceSuffix].apply(this, arguments);
    },

    /* Allow clone to correctly retrieve cached title attributes */
    clone: function(keepData) {
        var titles = $([]), title = 'title',

        // Clone our element using the real clone method
        elems = $.fn['clone'+replaceSuffix].apply(this, arguments);

        // Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
        if(!keepData) {
            elems.filter('['+oldtitle+']').attr('title', function() {
                return $.attr(this, oldtitle);
            })
            .removeAttr(oldtitle);
        }

        return elems;
    }
}, function(name, func) {
    if(!func || $.fn[name+replaceSuffix]) { return TRUE; }

    var old = $.fn[name+replaceSuffix] = $.fn[name];
    $.fn[name] = function() {
        return func.apply(this, arguments) || old.apply(this, arguments);
    };
});

/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
 * This snippet is taken directly from jQuery UI source code found here:
 *     http://code.jquery.com/ui/jquery-ui-git.js
 */
if(!$.ui) {
    $['cleanData'+replaceSuffix] = $.cleanData;
    $.cleanData = function( elems ) {
        for(var i = 0, elem; (elem = $( elems[i] )).length; i++) {
            if(elem.attr(ATTR_HAS)) {
                try { elem.triggerHandler('removeqtip'); }
                catch( e ) {}
            }
        }
        $['cleanData'+replaceSuffix].apply(this, arguments);
    };
}

;// qTip version
QTIP.version = '2.2.0';

// Base ID for all qTips
QTIP.nextid = 0;

// Inactive events array
QTIP.inactiveEvents = INACTIVE_EVENTS;

// Base z-index for all qTips
QTIP.zindex = 15000;

// Define configuration defaults
QTIP.defaults = {
    prerender: FALSE,
    id: FALSE,
    overwrite: TRUE,
    suppress: TRUE,
    content: {
        text: TRUE,
        attr: 'title',
        title: FALSE,
        button: FALSE
    },
    position: {
        my: 'top left',
        at: 'bottom right',
        target: FALSE,
        container: FALSE,
        viewport: FALSE,
        adjust: {
            x: 0, y: 0,
            mouse: TRUE,
            scroll: TRUE,
            resize: TRUE,
            method: 'flipinvert flipinvert'
        },
        effect: function(api, pos, viewport) {
            $(this).animate(pos, {
                duration: 200,
                queue: FALSE
            });
        }
    },
    show: {
        target: FALSE,
        event: 'mouseenter',
        effect: TRUE,
        delay: 90,
        solo: FALSE,
        ready: FALSE,
        autofocus: FALSE
    },
    hide: {
        target: FALSE,
        event: 'mouseleave',
        effect: TRUE,
        delay: 0,
        fixed: FALSE,
        inactive: FALSE,
        leave: 'window',
        distance: FALSE
    },
    style: {
        classes: '',
        widget: FALSE,
        width: FALSE,
        height: FALSE,
        def: TRUE
    },
    events: {
        render: NULL,
        move: NULL,
        show: NULL,
        hide: NULL,
        toggle: NULL,
        visible: NULL,
        hidden: NULL,
        focus: NULL,
        blur: NULL
    }
};

;}));
}( window, document ));




/* **********************************************
     Begin app.js
********************************************** */

var app = angular.module('PIDdemonstrator', []);

$('#detailCtrl').hide();

app.controller('ResultCtrl', ['$scope', '$http', '$q', function($scope, $http, $q) {

    // Ability to cancel requests
    var canceler = $q.defer();

    $scope.simple_works = [];
    $scope.index_works = [];
    $scope.normalised_works = [];

    $scope.loadWorks = function(queryObject) {
        // Cancel current requests
        canceler.resolve();
        canceler = $q.defer();

        // Query
        $http({
            url: baseURL + "query",
            method: 'GET',
            params: queryObject,
            timeout: canceler.promise
        }).success(function(data, status, headers, config) {
            // console.log(data);
            $scope.normalised_works = data;

            $('.results-normalised .fa-spin').stop().fadeOut();
            resetForm();
        }).error(function(data, status, headers, config) {
            if(data){
                // Show errors in alert
                var error = JSON.parse(data.responseText);
                error = error.error;
                alertify.error('An error occurred: ' + data.status + ' - ' + error.message);

                $('.results-normalised .fa-spin').stop().fadeOut();
                resetForm();
            }
        });

        var indexQueryObject = jQuery.extend({'type': 'index'}, queryObject);

        $http({
            url: baseURL + "query",
            method: 'GET',
            params: indexQueryObject,
            timeout: canceler.promise
        }).success(function(data, status, headers, config) {
            var object = {};
            object.count = data.length;
            object.results = data;

            $scope.index_works = object;

            $('.results-index .fa-spin').stop().fadeOut();
            resetForm();
        }).error(function(data, status, headers, config) {
            if(data){
                // Show errors in alert
                var error = JSON.parse(data.responseText);
                error = error.error;
                alertify.error('An error occurred: ' + data.status + ' - ' + error.message);

                $('.results-index .fa-spin').stop().fadeOut();
                resetForm();
            }
        });


        var simpleQueryObject = jQuery.extend({'type': 'simple'}, queryObject);

        $http({
            url: baseURL + "query",
            method: 'GET',
            params: simpleQueryObject,
            timeout: canceler.promise
        }).success(function(data, status, headers, config) {
            var object = {};
            object.count = data.length;
            object.results = data;

            $scope.simple_works = object;

            $('.results-simple .fa-spin').stop().fadeOut();
            resetForm();
        }).error(function(data, status, headers, config) {
            if(data){
                // Show errors in alert
                var error = JSON.parse(data.responseText);
                error = error.error;
                alertify.error('An error occurred: ' + data.status + ' - ' + error.message);

                $('.results-simple .fa-spin').stop().fadeOut();
                resetForm();
            }
        });

        $scope.$apply();
    };

    $scope.viewDetails = function(e) {
        angular.element($('#detailCtrl')).scope().viewDetails(e);
    }

    $scope.reset = function() {
        $('#detailCtrl').hide();

        // Clear results
        $scope.simple_works = [];
        $scope.index_works = [];
        $scope.normalised_works = [];
        $scope.$apply();
    }

}]);


app.controller('DetailCtrl', ['$scope', function($scope) {

    $scope.enriched = true;
    $scope.work_detail = {};

    $scope.goBack = function() {
        $('#detailCtrl').hide();
        $('#results').show();
        $('#searchForm').show();
        $scope.work_detail = {};
    }

    $scope.viewDetails = function(e) {
        console.log(e);
        $('#searchForm').hide();
        $('#results').hide();
        $('#detailCtrl').show();
        $scope.work_detail = e;

        // Push state
        history.pushState({}, 'PID demonstrator', '?' + $.param(queryObj));
    }
}]);

/**
 * Result count filter
 */
app.filter('resultCount', function() {
    return function(count) {
        if(count == 0 || count == undefined){
            status = 'Geen records';
        }else if(count == 1){
            status = '1 record';
        }else{
            status = count + ' records';
        }

        return status + ' gevonden';
    };
});

/**
 * Result count filter
 */
app.filter('workCount', function() {
    return function(count) {
        if(count == 0 || count == undefined){
            status = 'Geen werken';
        }else if(count == 1){
            status = '1 werk';
        }else{
            status = count + ' werken';
        }

        return status + ' gevonden';
    };
});


/**
 * Tooltips
 */
app.directive('ngTooltip', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var my = attrs.my || 'top center'
            , at = attrs.at || 'bottom center'
            , qtipClass = attrs.class || 'qtip-dark'
            , content

            if (attrs.title) {
                content = attrs.title
            }
            else {
                content = attrs.content
            }

            $(element).qtip({
                content: content,
                position: {
                    my: my,
                    at: at,
                    target: element
                },
                hide: {
                    fixed : true,
                    delay : 100
                },
                style: 'qtip-dark'
            })
        }
    }
});

/**
 * History detect
 */
$(window).bind('onPopState', function(){
    console.log('j');
})

window.onpopstate = function(event) {
    if(!$('#results').is(":visible")){
        $('#detailCtrl').hide();
        $('#results').show();
        $('#searchForm').show();
    }
};